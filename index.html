<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milano Cortina 2026 - Shift Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" onerror="document.body.innerHTML='<div style=\'padding:40px;text-align:center;font-family:sans-serif;\'><h2 style=\'color:#dc2626;\'>‚ö†Ô∏è Failed to load XLSX library</h2><p>The Excel parsing library could not be loaded from the CDN.</p><p>Please check your internet connection and try again.</p></div>'"></script>
    <!-- Olympic Winter Theme: Ice blues, deep navy, minimalist elegance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* ============================================
           OLYMPIC WINTER DESIGN SYSTEM
           Milano Cortina 2026
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Olympic Winter Color Palette */
            --ice-blue: #E3F2FD;
            --sky-blue: #90CAF9;
            --olympic-blue: #1976D2;
            --deep-navy: #0D47A1;
            --silver: #ECEFF1;
            --frost-white: #FAFAFA;
            --snow-white: #FFFFFF;
            --charcoal: #263238;
            --slate: #546E7A;
            --accent-gold: #FFB300;
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;
            
            /* Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
            --shadow-xl: 0 12px 36px rgba(0,0,0,0.15);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--ice-blue) 0%, var(--sky-blue) 100%);
            min-height: 100vh;
            padding: var(--space-lg);
            color: var(--charcoal);
            line-height: 1.6;
            font-size: 15px;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Olympic Header - Deep Navy Gradient */
        .header {
            background: linear-gradient(135deg, var(--deep-navy) 0%, var(--olympic-blue) 100%);
            padding: var(--space-lg) var(--space-xl);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-md);
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }
        
        /* Subtle Olympic rings pattern */
        .header::before {
            content: '';
            position: absolute;
            top: -50px;
            right: -50px;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .header h1 {
            color: var(--snow-white);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: var(--space-sm);
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }
        
        .header p {
            color: rgba(255,255,255,0.9);
            font-size: 1.1rem;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }
        
        /* File Upload Section */
        .file-input-container {
            background: var(--snow-white);
            padding: var(--space-2xl);
            border-radius: var(--radius-lg);
            text-align: center;
            margin-bottom: var(--space-xl);
            box-shadow: var(--shadow-md);
            border: 2px dashed var(--silver);
            transition: all 0.25s ease;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 71, 161, 0.85);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: var(--space-lg);
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: var(--snow-white);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: var(--snow-white);
            font-size: 1.25rem;
            font-weight: 500;
            text-align: center;
        }
        
        .loading-subtext {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            margin-top: -8px;
        }
        
        .file-input-container:hover {
            border-color: var(--olympic-blue);
            box-shadow: var(--shadow-lg);
        }
        
        .file-input-container h2 {
            color: var(--charcoal);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: var(--space-sm);
        }
        
        .file-input-container p {
            color: var(--slate);
            margin-bottom: var(--space-lg);
        }
        
        .file-input-container input[type="file"] {
            display: none;
        }
        
        .file-label {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-md) var(--space-xl);
            background: linear-gradient(135deg, var(--olympic-blue), var(--deep-navy));
            color: var(--snow-white);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.25s ease;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }
        
        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .file-label:active {
            transform: translateY(0);
        }
        
        /* Tabs - Olympic Rings Inspired */
        .tabs {
            display: flex;
            gap: var(--space-sm);
            background: var(--snow-white);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            min-width: 120px;
            padding: var(--space-md) var(--space-lg);
            background: transparent;
            border: none;
            color: var(--slate);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            font-size: 0.95rem;
            white-space: nowrap;
        }
        
        .tab:hover {
            background: var(--ice-blue);
            color: var(--olympic-blue);
        }
        
        .tab.active {
            background: linear-gradient(135deg, var(--olympic-blue), var(--deep-navy));
            color: var(--snow-white);
            box-shadow: var(--shadow-sm);
        }
        
        .my-shifts-btn,
        .execute-saved-search-btn {
            padding: var(--space-sm) var(--space-lg);
            border-radius: var(--radius-full);
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        
        .my-shifts-btn:disabled,
        .execute-saved-search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-unset-transition {
            background: linear-gradient(135deg, rgba(79,70,229,0.4), rgba(124,58,237,0.4)) !important;
            color: #1f2937 !important;
        }

        .button-unset-complete {
            background: #f3f4f6 !important;
            color: #1f2937 !important;
            box-shadow: none !important;
        }
        
        /* Search & Filters Section */
        .search-container {
            background: var(--snow-white);
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            box-shadow: var(--shadow-sm);
        }
        
        .search-input {
            flex: 1;
            min-width: 250px;
            padding: var(--space-md);
            border: 2px solid var(--silver);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            font-family: inherit;
            transition: all 0.15s ease;
            background: var(--frost-white);
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--olympic-blue);
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            background: var(--snow-white);
        }
        
        .search-input::placeholder {
            color: var(--slate);
            opacity: 0.6;
        }
        
        .search-help {
            margin-top: 10px;
            font-size: 14px;
            color: #6b7280;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .filter-select {
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .person-select-container {
            position: relative;
            flex: 1;
            min-width: 200px;
        }
        
        .person-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .person-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .person-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .person-dropdown.show {
            display: block;
        }
        
        .person-option {
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .person-option:hover {
            background: #f3f4f6;
        }
        
        .person-option.selected {
            background: #e0e7ff;
            color: #667eea;
            font-weight: 500;
        }
        
        .content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        
        /* Shift Cards - Elegant Design */
        .shift-card {
            background: var(--snow-white);
            border-radius: var(--radius-sm);
            padding: 10px 12px;
            margin-bottom: 6px;
            box-shadow: var(--shadow-sm);
            transition: all 0.25s ease;
            border: 1px solid transparent;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .shift-card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
            border-color: var(--olympic-blue);
        }

        @keyframes criticalFlash {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            50% {
                opacity: 0.55;
                transform: translateY(-2px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(245, 158, 11, 0);
            }
        }

        .last-update-flash {
            animation: criticalFlash 0.8s ease-in-out infinite;
        }
        
        .shift-card.unassigned {
            border-left: 4px solid var(--accent-gold);
        }
        
        /* Card Header */
        .shift-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .shift-header-info {
            /* Container for name and role */
            display: block;
        }
        
        .shift-name {
            font-size: 17px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 1px;
            line-height: 1.2;
        }
        
        .shift-role {
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            line-height: 1.2;
        }
        
        .shift-badge {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
            line-height: 1.4;
            color: white;
        }
        
        .badge-assigned {
            background: #10b981;
        }
        
        .badge-unassigned {
            background: #f59e0b;
        }
        
        /* Card Details Grid */
        .shift-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 4px 16px;
            margin-bottom: 4px;
        }
        
        .shift-detail {
            /* Container for label + value */
            display: block;
        }
        
        .shift-detail-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #9ca3af;
            font-weight: 600;
            margin-bottom: 1px;
            line-height: 1.3;
        }
        
        .shift-detail-value {
            font-size: 13px;
            color: #1f2937;
            font-weight: 500;
            line-height: 1.3;
        }
        
        /* Contact Section */
        .shift-contact {
            background: #f9fafb;
            padding: 5px 8px;
            border-radius: 4px;
            border-left: 2px solid #667eea;
            margin-top: 4px;
        }
        
        .shift-contact-icon {
            font-size: 10px;
            text-transform: uppercase;
            color: #667eea;
            font-weight: 600;
            margin-right: 8px;
        }
        
        .shift-contact-separator {
            color: #d1d5db;
        }
        
        .shift-contact-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            font-size: 12px;
        }
        
        .shift-contact-email {
            color: #6b7280;
            font-size: 12px;
        }
        
        .shift-contact-phone {
            color: #374151;
            font-size: 12px;
        }
        
        .shift-copy-btn {
            background: transparent;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            padding: 1px 5px;
            cursor: pointer;
            font-size: 10px;
            color: #6b7280;
            transition: all 0.15s;
            margin-left: 3px;
        }
        
        .shift-copy-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        /* Stats Badges */
        .stat-badge {
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .stat-badge-total {
            background: var(--ice-blue);
            color: var(--charcoal);
        }
        
        .stat-badge-assigned {
            background: #d1fae5;
            color: #065f46;
        }
        
        .stat-badge-unassigned {
            background: #fef3c7;
            color: #92400e;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        /* Export Buttons */
        .export-excel-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            background: linear-gradient(135deg, #10b981, #059669);
            color: var(--snow-white);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        
        .export-excel-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .export-excel-btn:active {
            transform: translateY(0);
        }
        
        /* Calendar Export Button */
        .export-calendar-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            background: linear-gradient(135deg, #059669, #047857);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: auto;
        }
        
        .export-calendar-btn:hover {
            background: linear-gradient(135deg, #047857, #065f46);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.3);
        }
        
        .export-calendar-btn:active {
            transform: translateY(0);
        }
        
        /* Export Modal Overlay */
        .export-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .export-modal-overlay.show {
            display: flex;
        }
        
        .export-modal {
            background: var(--snow-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            max-width: 480px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.25s ease;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .export-modal-header {
            padding: var(--space-lg);
            border-bottom: 1px solid var(--silver);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .export-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            color: var(--charcoal);
        }
        
        .export-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--slate);
            padding: 4px;
            line-height: 1;
            transition: color 0.15s;
        }
        
        .export-modal-close:hover {
            color: var(--charcoal);
        }
        
        .export-modal-body {
            padding: var(--space-lg);
        }
        
        .export-option {
            padding: var(--space-md);
            border: 2px solid var(--silver);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .export-option:hover {
            border-color: var(--olympic-blue);
            background: var(--ice-blue);
        }
        
        .export-option-title {
            font-weight: 600;
            color: var(--charcoal);
            margin-bottom: 4px;
        }
        
        .export-option-desc {
            font-size: 0.85rem;
            color: var(--slate);
        }
        
        .export-option-count {
            display: inline-block;
            background: var(--olympic-blue);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 8px;
        }
        
        .export-changes-summary {
            margin-top: var(--space-lg);
            padding: var(--space-md);
            background: var(--frost-white);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--olympic-blue);
        }
        
        .export-changes-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--charcoal);
            margin-bottom: var(--space-sm);
        }
        
        .export-changes-stats {
            display: flex;
            gap: var(--space-md);
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        .export-change-new { color: #059669; }
        .export-change-modified { color: #d97706; }
        .export-change-removed { color: #dc2626; }
        
        .export-removed-list {
            margin-top: var(--space-sm);
            padding-top: var(--space-sm);
            border-top: 1px solid var(--silver);
            font-size: 0.8rem;
            color: var(--slate);
            max-height: 150px;
            overflow-y: auto;
        }
        
        .export-removed-item {
            padding: 4px 0;
            color: #dc2626;
        }
        
        .export-toggle-removed {
            background: none;
            border: none;
            color: var(--olympic-blue);
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0;
            margin-top: var(--space-sm);
        }
        
        .export-toggle-removed:hover {
            text-decoration: underline;
        }
        
        /* Calendar View Modal */
        .calendar-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .calendar-modal-overlay.show {
            display: flex;
        }
        
        .calendar-modal {
            background: #f5f7fa;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .calendar-modal-header {
            padding: var(--space-md) var(--space-lg);
            background: linear-gradient(135deg, var(--deep-navy) 0%, var(--olympic-blue) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .calendar-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
        }
        
        .calendar-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.15s;
        }
        
        .calendar-modal-close:hover {
            opacity: 1;
        }
        
        .calendar-modal-body {
            padding: var(--space-lg);
            overflow-y: auto;
            flex: 1;
        }
        
        .calendar-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .calendar-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }
        
        .calendar-legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .calendar-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .calendar-month-header {
            background: var(--deep-navy);
            color: white;
            padding: 12px 20px;
            font-size: 18px;
            font-weight: 600;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }
        
        .calendar-day-header {
            background: #e2e8f0;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 12px;
            color: #475569;
            border-bottom: 1px solid #cbd5e1;
        }
        
        .calendar-day-cell {
            min-height: 100px;
            border: 1px solid #e2e8f0;
            padding: 5px;
            background: white;
        }
        
        .calendar-day-cell.empty { background: #f8fafc; }
        .calendar-day-cell.weekend { background: #fefce8; }
        
        .calendar-day-number {
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 5px;
        }
        
        .calendar-day-cell.weekend .calendar-day-number { color: #b45309; }
        
        .calendar-shift {
            font-size: 10px;
            padding: 4px 6px;
            margin-bottom: 3px;
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            color: white;
        }
        
        .calendar-shift-name { font-weight: 600; }
        .calendar-shift-time { opacity: 0.9; font-size: 9px; }
        .calendar-shift-role { font-size: 8px; opacity: 0.8; }
        
        .calendar-shift.shift-morning { border-left: 4px solid #fbbf24; }
        .calendar-shift.shift-afternoon { border-left: 4px solid #f97316; }
        .calendar-shift.shift-night { border-left: 4px solid #1e3a5a; }
        
        .calendar-shift.shift-off {
            background: #e5e7eb !important;
            color: #9ca3af;
        }
        
        .calendar-shift.shift-short {
            background-image: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(255,255,255,0.4) 3px,
                rgba(255,255,255,0.4) 6px
            ) !important;
        }
        
        .calendar-view-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            background: linear-gradient(135deg, var(--olympic-blue), var(--deep-navy));
            color: var(--snow-white);
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        
        .calendar-view-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .export-modal-footer {
            padding: var(--space-md) var(--space-lg);
            border-top: 1px solid var(--silver);
            display: flex;
            justify-content: flex-end;
        }
        
        .export-cancel-btn {
            padding: var(--space-sm) var(--space-lg);
            background: var(--frost-white);
            border: 2px solid var(--silver);
            border-radius: var(--radius-sm);
            color: var(--charcoal);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .export-cancel-btn:hover {
            background: var(--silver);
        }
        
        /* Statistics Bar */
        .stats {
            background: var(--snow-white);
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            display: flex;
            gap: var(--space-xl);
            align-items: center;
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }
        
        .stat-card {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .stat-label {
            color: var(--slate);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .stat-number {
            color: var(--olympic-blue);
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: var(--space-md);
            }
            
            .header {
                padding: var(--space-xl) var(--space-lg);
            }
            
            .header h1 {
                font-size: 1.75rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                width: 100%;
            }
            
            .shift-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-sm);
            }
            
            .shift-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="position: absolute; top: 20px; right: 24px; z-index: 12;">
                <a href="USER_GUIDE.html" target="_blank" style="color: white; text-decoration: none; font-size: 0.9rem; padding: 8px 16px; background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border-radius: 8px; transition: all 0.25s; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; font-weight: 500; border: 1px solid rgba(255,255,255,0.2);" onmouseover="this.style.background='rgba(255,255,255,0.25)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255,255,255,0.15)'; this.style.transform='translateY(0)'">
                    <span>‚ùì</span>
                    <span>Help / User Guide</span>
                </a>
            </div>
            <h1>üèîÔ∏è Milano Cortina 2026 - Shift Viewer <span id="lastUpdateDisplay" style="font-size: 0.5em; font-weight: 400; opacity: 0.9;"></span></h1>
            <p>Olympic shift schedule viewing made simple</p>
        </div>
        
        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Excel File...</div>
            <div class="loading-subtext">This may take a few seconds</div>
        </div>
        
        <div class="file-input-container" id="fileInputContainer">
            <h2>üìä Load Shift Schedule</h2>
            
            <!-- Buttons Container - centered on page -->
            <div style="margin-top: 20px; display: flex; flex-direction: column; align-items: center; width: 400px; margin-left: auto; margin-right: auto;">
                <!-- Single File Selection Button -->
                <div style="width: 100%;">
                    <label id="chooseFileLabel" for="fileInput" class="file-label" style="margin: 0; width: 100%; text-align: center; justify-content: center;">
                        üìÅ Select Excel File
                    </label>
                </div>
                
                <!-- Last File Info (shown if available) -->
                <div id="savedFileRow" style="display: none; margin-top: 12px; text-align: center;">
                    <span style="font-size: 0.8rem; color: var(--slate);">Last file: </span>
                    <span id="savedFileName" style="font-size: 0.8rem; color: var(--olympic-blue);"></span>
                    <span id="savedFileInfo" style="font-size: 0.75rem; color: var(--slate); margin-left: 8px;"></span>
                </div>
            </div>
            <input type="file" id="fileInput" accept=".xlsx,.xls,.xlsm,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,application/vnd.ms-excel.sheet.macroEnabled.12" style="display: none;">
            <p id="fileName" style="margin-top: 12px;"></p>
            
            <!-- Initial Setup Tip -->
            <div style="margin-top: 24px; padding: 16px; background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 8px; border: 1px solid #bae6fd; text-align: left;">
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <span style="font-size: 1.5rem;">üí°</span>
                    <div>
                        <strong style="color: var(--deep-navy);">Two Ways to Get the Schedule File</strong>
                        <p style="margin: 6px 0 0 0; font-size: 0.9rem; color: var(--slate); line-height: 1.6;">
                            <strong>Option 1 - Manual Download:</strong> Click this <a href="https://dtpsso.sharepoint.com/sites/DTEC_COLE_MICO26/SitePages/Published-Shift-Schedule.aspx" target="_blank" style="color: var(--olympic-blue); font-weight: 500;">COLE link</a>, download the Excel file, then select it here. Repeat each time you want the latest schedule.
                            <br><br>
                            <strong>Option 2 - OneDrive Sync (Recommended):</strong> Set up OneDrive sync once, and the file stays current automatically on your computer. You'll still need to click "Choose/Refresh" to reload, but you won't need to download again.
                            <a href="USER_GUIDE.html#onedrive-sync" target="_blank" style="color: var(--olympic-blue); font-weight: 500; margin-left: 4px;">Setup guide ‚Üí</a>
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- OneDrive Sync Warning -->
            <div style="margin-top: 12px; padding: 16px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 8px; border: 1px solid #f59e0b; text-align: left;">
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <div>
                        <strong style="color: #92400e;">Important: Manual Refresh Always Required</strong>
                        <p style="margin: 6px 0 0 0; font-size: 0.9rem; color: #78350f; line-height: 1.5;">
                            Even with OneDrive sync, <strong>you must click "Choose/Refresh Excel File"</strong> each time you want to load updated data. Browser security prevents automatic detection of file changes.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="appContainer" style="display: none;">
            
            <!-- COMPACT CONTROLS ROW -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); margin-bottom: var(--space-md); box-shadow: var(--shadow-sm);">
                <!-- Tabs -->
                <div class="tabs" style="margin-bottom: 0;">
                    <button class="tab active" data-tab="upcoming">üìã Upcoming</button>
                    <button class="tab" data-tab="current">üî¥ Current</button>
                    <button class="tab" data-tab="today">üìÜ Today</button>
                    <button class="tab" data-tab="tomorrow">üìÖ Tomorrow</button>
                    <button class="tab" data-tab="search">üîç All</button>
                </div>
            </div>
            
            <!-- COMPACT FILTERS ROW -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); margin-bottom: var(--space-md); box-shadow: var(--shadow-sm);">
                <div style="display: grid; grid-template-columns: 1fr auto auto; gap: var(--space-sm); align-items: center;">
                    <!-- Main Search -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input type="text" class="search-input" id="searchInput" placeholder="üîç Search shifts..." style="flex: 1;">
                        <button id="searchInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="Search Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="searchTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 420px; box-shadow: var(--shadow-xl); top: 45px; right: 0; line-height: 1.6;">
                            <strong style="color: var(--sky-blue);">Search Tips:</strong><br>
                            ‚Ä¢ <strong>General:</strong> John (searches name, role, venue, type)<br>
                            ‚Ä¢ <strong>Multiple terms (AND):</strong> wmr olena<br>
                            ‚Ä¢ <strong>OR search:</strong> corless OR nadal OR nasr (multiple ORs supported)<br>
                            ‚Ä¢ <strong>Quoted phrase:</strong> "duty manager"<br>
                            ‚Ä¢ <strong>Exclude terms:</strong> -RTOC or venue:TOC -RTOC<br>
                            ‚Ä¢ <strong>Assignment status:</strong> assigned or unassigned<br>
                            ‚Ä¢ <strong>Type search:</strong> virtual or "on site"<br>
                            ‚Ä¢ <strong>Combine filters:</strong> unassigned wmr -virtual<br>
                            ‚Ä¢ <strong>Specific field:</strong> role:WMR<br>
                            ‚Ä¢ <strong>Multiple fields:</strong> name:Olena venue:RTOC<br>
                            ‚Ä¢ <strong>Date search:</strong> date:15/11 or date:11/15<br>
                            &nbsp;&nbsp;(tries both EU and US formats)<br>
                            ‚Ä¢ <strong>Date with year:</strong> date:15/11/2025<br>
                            ‚Ä¢ Year inference: Nov-Dec‚Üí2025, Jan-Mar‚Üí2026<br>
                            ‚Ä¢ All searches are case insensitive<br>
                            ‚Ä¢ Supported fields: name, role, venue, date
                        </div>
                    </div>
                    
                    
                    <!-- My Shifts -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input 
                            type="text" 
                            id="myNameInput" 
                            placeholder="Name or role"
                            class="search-input"
                            style="width: 150px; color: #9ca3af;"
                        >
                        <button 
                            id="myShiftsBtn" 
                            class="file-label" 
                            style="padding: var(--space-sm) var(--space-md); cursor: not-allowed; opacity: 0.5; background: var(--frost-white); color: var(--charcoal); border: 2px solid var(--silver); white-space: nowrap;"
                            disabled
                        >
                            üë§ My Shifts
                        </button>
                        <button id="myNameInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="My Name Filter Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="myNameTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 300px; box-shadow: var(--shadow-xl); top: 45px; right: 0;">
                            <strong style="color: var(--sky-blue);">My Shifts Filter:</strong><br>
                            Enter your name or role and click "My Shifts" to filter matching shifts. Your filter is saved across sessions but deactivated by default. Works with tab filters (e.g., "Upcoming" + "My Shifts" = your upcoming shifts).
                        </div>
                    </div>
                    
                    
                    <!-- Saved Search -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input 
                            type="text" 
                            class="search-input" 
                            id="savedSearchInput" 
                            placeholder="Saved search"
                            style="width: 200px;"
                        >
                        <button class="file-label" id="executeSavedSearch" style="padding: var(--space-sm) var(--space-md); cursor: not-allowed; background: var(--frost-white); color: var(--charcoal); opacity: 0.5; border: 2px solid var(--silver); white-space: nowrap;" disabled>
                            ‚ñ∂Ô∏è Execute
                        </button>
                        <button id="savedSearchInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="Saved Search Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="savedSearchTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 300px; box-shadow: var(--shadow-xl); top: 45px; right: 0;">
                            <strong style="color: var(--sky-blue);">Saved Search:</strong><br>
                            Your search is automatically saved across sessions. Click "Execute" to toggle the search on/off. Uses the same powerful search syntax as the main search box.
                    </div>
                </div>
            </div>
            
            <!-- RESULTS -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); box-shadow: var(--shadow-sm);">
                <!-- Compact stats header -->
                <div id="stats" style="font-size: 11px; color: var(--slate); margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--silver); display: flex; gap: 8px;"></div>
                <div id="content">
                    <div class="loading">Loading shifts...</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Calendar Export Modal -->
    <div id="exportModal" class="export-modal-overlay">
        <div class="export-modal">
            <div class="export-modal-header">
                <h3>üì§ Export Shifts</h3>
                <button class="export-modal-close" onclick="closeExportModal()">&times;</button>
            </div>
            <div class="export-modal-body">
                <p style="margin-bottom: var(--space-md); color: var(--slate);">
                    Export <strong><span id="exportDisplayedCount">0</span> displayed shifts</strong> to Excel or Calendar format.
                </p>
                
                <!-- Show As Option -->
                <div style="margin-bottom: var(--space-md); padding: var(--space-md); background: var(--frost-white); border-radius: var(--radius-sm); border: 1px solid var(--silver);">
                    <div style="font-weight: 600; color: var(--charcoal); margin-bottom: var(--space-sm); font-size: 0.9rem;">Show time as:</div>
                    <div style="display: flex; gap: var(--space-md);">
                        <label style="display: flex; align-items: center; gap: var(--space-sm); cursor: pointer;">
                            <input type="radio" name="showAs" value="BUSY" checked style="accent-color: var(--olympic-blue);">
                            <span style="font-size: 0.9rem; color: var(--charcoal);">Busy</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: var(--space-sm); cursor: pointer;">
                            <input type="radio" name="showAs" value="FREE" style="accent-color: var(--olympic-blue);">
                            <span style="font-size: 0.9rem; color: var(--charcoal);">Free</span>
                        </label>
                    </div>
                </div>
                
                <div class="tip" style="margin-top: var(--space-md); font-size: 0.85rem;">
                    <strong>üí° Tip:</strong> To update your calendar, search <code>category:ShiftViewer</code> in Outlook, delete all results, then import the new file.
                </div>
            </div>
            <div class="export-modal-footer">
                <button class="export-cancel-btn" onclick="closeExportModal()">Cancel</button>
                <button class="export-excel-btn" onclick="exportToExcel()" style="margin-left: var(--space-sm);">üìä Excel</button>
                <button class="export-calendar-btn" onclick="exportShifts()" style="margin-left: var(--space-sm);">üìÖ Calendar</button>
            </div>
        </div>
    </div>
    
    <!-- Calendar View Modal -->
    <div id="calendarModal" class="calendar-modal-overlay">
        <div class="calendar-modal">
            <div class="calendar-modal-header">
                <h3>üìÖ Calendar View</h3>
                <button class="calendar-modal-close" onclick="closeCalendarModal()">&times;</button>
            </div>
            <div class="calendar-modal-body">
                <div id="calendarLegend" class="calendar-legend"></div>
                <div id="calendarContent"></div>
            </div>
        </div>
    </div>

    <script>
        // Global error handler to catch and display any JavaScript errors
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('JavaScript Error:', msg, 'at line', lineNo);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#fef2f2;border-bottom:2px solid #dc2626;padding:16px;z-index:99999;font-family:sans-serif;';
            errorDiv.innerHTML = '<strong style="color:#dc2626;">‚ö†Ô∏è JavaScript Error:</strong> ' + msg + ' (line ' + lineNo + ')';
            document.body.insertBefore(errorDiv, document.body.firstChild);
            return false;
        };
        
        // ============================================
        // CONFIGURATION & DEBUG
        // ============================================
        
        // Debug flag system - set to true to enable console logging
        // Can also be enabled by running: localStorage.setItem('DEBUG', 'true')
        const DEBUG = localStorage.getItem('DEBUG') === 'true' || false;
        
        // Debug logging wrapper
        const debug = {
            log: (...args) => DEBUG && console.log(...args),
            warn: (...args) => DEBUG && console.warn(...args),
            info: (...args) => DEBUG && console.info(...args),
            error: (...args) => console.error(...args) // Always show errors
        };
        
        // ============================================
        // SECURITY UTILITIES
        // ============================================
        
        // XSS Protection: Escape HTML entities in user-provided data
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        // Escape for use in HTML attributes (stricter escaping)
        function escapeAttr(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;')
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }
        
        // ============================================
        // APPLICATION STATE
        // ============================================
        
        let allShifts = [];
        let currentTab = 'upcoming';
        let allPeople = [];
        let selectedPerson = '';
        let lastUpdateTime = null;
        let myShiftsFilter = ''; // Name filter for "My Shifts"
        let includeUnassigned = false; // Whether to show unassigned shifts
        let lastUpdateFlashTimeout = null;
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        // Cached date computations (refreshed every minute)
        let cachedDates = null;
        function getCachedDates() {
            const now = Date.now();
            // Refresh cache if it's null or older than 60 seconds
            if (!cachedDates || now - cachedDates.timestamp > 60000) {
                const currentDate = new Date();
                const todayNormalized = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                const tomorrowNormalized = new Date(todayNormalized);
                tomorrowNormalized.setDate(tomorrowNormalized.getDate() + 1);
                
                cachedDates = {
                    now: currentDate,
                    today: todayNormalized,
                    tomorrow: tomorrowNormalized,
                    todayString: todayNormalized.toDateString(),
                    tomorrowString: tomorrowNormalized.toDateString(),
                    timestamp: now
                };
                debug.log('Date cache refreshed:', cachedDates.today.toDateString());
            }
            return cachedDates;
        }
        
        function highlightUnsetButton(button) {
            if (!button) return;
            button.classList.remove('button-unset-transition', 'button-unset-complete');
            // Force reflow to restart animation
            void button.offsetWidth;
            button.classList.add('button-unset-transition');
            setTimeout(() => {
                if (!button.classList.contains('button-unset-transition')) return;
                button.classList.remove('button-unset-transition');
                button.classList.add('button-unset-complete');
                setTimeout(() => {
                    button.classList.remove('button-unset-complete');
                    button.style.background = '#f3f4f6';
                }, 300);
            }, 400);
        }

        // Copy email to clipboard function
        function copyEmail(email, button) {
            navigator.clipboard.writeText(email).then(() => {
                // Store original button content
                const originalHTML = button.innerHTML;
                const originalColor = button.style.color;
                
                // Show success feedback
                button.innerHTML = '‚úì Copied!';
                button.style.color = '#10b981';
                button.style.borderColor = '#10b981';
                button.style.background = '#d1fae5';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.style.color = originalColor;
                    button.style.borderColor = '#d1d5db';
                    button.style.background = 'transparent';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy email:', err);
                button.innerHTML = '‚úó Failed';
                button.style.color = '#ef4444';
                setTimeout(() => {
                    button.innerHTML = 'üìã Copy';
                    button.style.color = '#6b7280';
                }, 2000);
            });
        }
        
        // ============================================
        // CALENDAR EXPORT FUNCTIONS
        // ============================================
        
        // Generate a stable UID for a shift (used for change detection)
        function generateShiftUID(shift) {
            // Format: mico26-YYYYMMDD-VENUE-ROLE-HHMM@shiftviewer
            const dateStr = shift.date ? 
                shift.date.getFullYear().toString() +
                String(shift.date.getMonth() + 1).padStart(2, '0') +
                String(shift.date.getDate()).padStart(2, '0') : 'NODATE';
            
            // Extract start time from shiftTimeCET (e.g., "08:00-16:00" -> "0800")
            let startTime = '0000';
            if (shift.shiftTimeCET) {
                const timeMatch = shift.shiftTimeCET.match(/(\d{1,2}):(\d{2})/);
                if (timeMatch) {
                    startTime = String(timeMatch[1]).padStart(2, '0') + timeMatch[2];
                }
            }
            
            // Sanitize venue and role for UID (remove spaces, special chars)
            const venue = (shift.venue || 'UNKNOWN').replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
            const role = (shift.role || 'UNKNOWN').replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
            
            return `mico26-${dateStr}-${venue}-${role}-${startTime}@shiftviewer`;
        }
        
        // Generate shift hash for detecting modifications (includes all relevant fields)
        function generateShiftHash(shift) {
            const parts = [
                shift.date ? shift.date.toISOString().split('T')[0] : '',
                shift.venue || '',
                shift.role || '',
                shift.shiftTimeCET || '',
                shift.location || '',
                shift.shiftType || ''
            ];
            return parts.join('|');
        }
        
        // Format date for ICS (YYYYMMDD)
        function formatICSDate(date) {
            return date.getFullYear().toString() +
                String(date.getMonth() + 1).padStart(2, '0') +
                String(date.getDate()).padStart(2, '0');
        }
        
        // Format datetime for ICS with timezone (YYYYMMDDTHHMMSS)
        function formatICSDateTime(date, hours, minutes) {
            return formatICSDate(date) + 'T' +
                String(hours).padStart(2, '0') +
                String(minutes).padStart(2, '0') + '00';
        }
        
        // Parse shift time string to get start and end hours/minutes
        function parseShiftTime(timeStr) {
            // Expected format: "08:00-16:00" or "08:00 - 16:00"
            const match = timeStr.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
            if (match) {
                return {
                    startHour: parseInt(match[1]),
                    startMin: parseInt(match[2]),
                    endHour: parseInt(match[3]),
                    endMin: parseInt(match[4])
                };
            }
            // Default to 9-5 if parsing fails
            return { startHour: 9, startMin: 0, endHour: 17, endMin: 0 };
        }
        
        // Escape special characters for ICS format
        function escapeICS(text) {
            if (!text) return '';
            return text
                .replace(/\\/g, '\\\\')
                .replace(/;/g, '\\;')
                .replace(/,/g, '\\,')
                .replace(/\n/g, '\\n');
        }
        
        // Generate ICS file content for shifts
        function generateICSContent(shifts, showAsBusy = true) {
            const lines = [
                'BEGIN:VCALENDAR',
                'VERSION:2.0',
                'PRODID:-//ShiftViewer//Milano Cortina 2026//EN',
                'CALSCALE:GREGORIAN',
                'METHOD:PUBLISH',
                'X-WR-CALNAME:My CO26 Shifts',
                'X-WR-TIMEZONE:Europe/Rome',
                // Timezone definition for CET/CEST
                'BEGIN:VTIMEZONE',
                'TZID:Europe/Rome',
                'BEGIN:DAYLIGHT',
                'TZOFFSETFROM:+0100',
                'TZOFFSETTO:+0200',
                'TZNAME:CEST',
                'DTSTART:19700329T020000',
                'RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU',
                'END:DAYLIGHT',
                'BEGIN:STANDARD',
                'TZOFFSETFROM:+0200',
                'TZOFFSETTO:+0100',
                'TZNAME:CET',
                'DTSTART:19701025T030000',
                'RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU',
                'END:STANDARD',
                'END:VTIMEZONE'
            ];
            
            const now = new Date();
            const dtstamp = formatICSDate(now) + 'T' + 
                String(now.getUTCHours()).padStart(2, '0') +
                String(now.getUTCMinutes()).padStart(2, '0') +
                String(now.getUTCSeconds()).padStart(2, '0') + 'Z';
            
            // Add confirmed events for current shifts
            shifts.forEach(shift => {
                const uid = generateShiftUID(shift);
                const time = parseShiftTime(shift.shiftTimeCET || '09:00-17:00');
                
                // Build description
                const descParts = [];
                if (shift.role) descParts.push('Role: ' + shift.role);
                if (shift.venue) descParts.push('Venue: ' + shift.venue);
                if (shift.location) descParts.push('Location: ' + shift.location);
                if (shift.shiftType) descParts.push('Type: ' + shift.shiftType);
                if (shift.shiftTimeCET) descParts.push('Time: ' + shift.shiftTimeCET + ' CET');
                const description = descParts.join('\\n');
                
                // Build summary: [Role] @ [Venue]
                const summary = (shift.role || 'Shift') + ' @ ' + (shift.venue || 'TBD');
                
                // Build location
                const location = [shift.venue, shift.location].filter(Boolean).join(' - ');
                
                lines.push('BEGIN:VEVENT');
                lines.push('UID:' + uid);
                lines.push('DTSTAMP:' + dtstamp);
                
                // Handle overnight shifts (end time <= start time means shift crosses midnight)
                const isOvernight = (time.endHour < time.startHour) || 
                                    (time.endHour === time.startHour && time.endMin <= time.startMin);
                let endDate = shift.date;
                if (isOvernight) {
                    endDate = new Date(shift.date);
                    endDate.setDate(endDate.getDate() + 1);
                }
                
                lines.push('DTSTART;TZID=Europe/Rome:' + formatICSDateTime(shift.date, time.startHour, time.startMin));
                lines.push('DTEND;TZID=Europe/Rome:' + formatICSDateTime(endDate, time.endHour, time.endMin));
                lines.push('SUMMARY:' + escapeICS(summary));
                if (location) lines.push('LOCATION:' + escapeICS(location));
                if (description) lines.push('DESCRIPTION:' + description);
                lines.push('CATEGORIES:' + escapeICS('ShiftViewer'));
                // Outlook-specific color category (X-MICROSOFT-CDO properties)
                const busyStatus = showAsBusy ? 'BUSY' : 'FREE';
                const transp = showAsBusy ? 'OPAQUE' : 'TRANSPARENT';
                lines.push('X-MICROSOFT-CDO-BUSYSTATUS:' + busyStatus);
                lines.push('STATUS:CONFIRMED');
                lines.push('TRANSP:' + transp);
                lines.push('END:VEVENT');
            });
            
            lines.push('END:VCALENDAR');
            return lines.join('\r\n');
        }
        
        
        // Get shifts filtered by "My Shifts" (matches name or role)
        function getMyShifts() {
            if (!myShiftsFilter) return [];
            const filterLower = myShiftsFilter.toLowerCase();
            return allShifts.filter(shift => 
                (shift.name && shift.name.toLowerCase().includes(filterLower)) ||
                (shift.role && shift.role.toLowerCase().includes(filterLower))
            );
        }
        
        // Get currently displayed shifts (respects all active filters)
        function getDisplayedShifts() {
            // Re-apply all current filters to get what's displayed
            let filtered = [...allShifts];
            
            // Exclude unassigned shifts by default
            if (!includeUnassigned) {
                filtered = filtered.filter(shift => shift.isAssigned);
            }
            
            // Tab filter
            const dates = getCachedDates();
            const { now, today, tomorrow, todayString, tomorrowString } = dates;
            
            switch(currentTab) {
                case 'current':
                    const currentHour = now.getHours();
                    const yesterdayForExport = new Date(now.getTime() - 86400000).toDateString();
                    filtered = filtered.filter(shift => {
                        if (!shift.dateString || !shift.shiftTimeCET) return false;
                        const timeMatch = shift.shiftTimeCET.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                        if (!timeMatch) return false;
                        
                        const startHour = parseInt(timeMatch[1]);
                        const endHour = parseInt(timeMatch[3]);
                        const isOvernight = endHour <= startHour;
                        const isToday = shift.dateString === todayString;
                        const isYesterday = shift.dateString === yesterdayForExport;
                        
                        if (isOvernight) {
                            // Evening portion: shift started today, currently in evening hours
                            if (isToday && currentHour >= startHour) return true;
                            // Morning portion: shift started yesterday, currently before end time
                            if (isYesterday && currentHour < endHour) return true;
                            return false;
                        } else {
                            // Normal shift: must be today and within hours
                            return isToday && currentHour >= startHour && currentHour < endHour;
                        }
                    });
                    break;
                case 'today':
                    filtered = filtered.filter(shift => shift.dateString === todayString);
                    break;
                case 'tomorrow':
                    filtered = filtered.filter(shift => shift.dateString === tomorrowString);
                    break;
                case 'upcoming':
                    filtered = filtered.filter(shift => shift.date && shift.date >= today);
                    break;
            }
            
            // Search filter (same logic as renderShifts)
            if (searchInput && searchInput.value) {
                const searchTerm = searchInput.value.trim();
                if (searchTerm) {
                    const fieldMatches = searchTerm.matchAll(/(name|role|venue|date):\s*([^\s]+)/gi);
                    const fieldCriteria = {};
                    let dateCriteria = null;
                    let processedIndices = [];
                    
                    for (const match of fieldMatches) {
                        const field = match[1].toLowerCase();
                        const value = match[2];
                        if (field === 'date') {
                            const parsedDates = parseSearchDate(value);
                            if (parsedDates && parsedDates.length > 0) {
                                dateCriteria = parsedDates;
                            }
                        } else {
                            fieldCriteria[field] = value.toLowerCase();
                        }
                        processedIndices.push({ start: match.index, end: match.index + match[0].length });
                    }
                    
                    let generalTerms = searchTerm;
                    processedIndices.sort((a, b) => b.start - a.start);
                    processedIndices.forEach(range => {
                        generalTerms = generalTerms.substring(0, range.start) + generalTerms.substring(range.end);
                    });
                    generalTerms = generalTerms.trim().toLowerCase();
                    
                    if (generalTerms && /^(name|role|venue|date):\s*$/i.test(generalTerms)) {
                        generalTerms = '';
                    }
                    
                    let positiveTerms = [];
                    let negativeTerms = [];
                    let orTerms = [];
                    if (generalTerms) {
                        // Check if the search contains OR logic
                        if (/\sOR\s/i.test(generalTerms)) {
                            const orParts = generalTerms.split(/\s+OR\s+/i);
                            for (const part of orParts) {
                                const trimmed = part.trim();
                                if (!trimmed) continue;
                                const quoteMatch = trimmed.match(/^"([^"]+)"$/);
                                if (quoteMatch) {
                                    orTerms.push(quoteMatch[1].toLowerCase());
                                } else {
                                    orTerms.push(trimmed.toLowerCase());
                                }
                            }
                        } else {
                            const regex = /"([^"]+)"|([^\s]+)/g;
                            let match;
                            while ((match = regex.exec(generalTerms)) !== null) {
                                let term = (match[1] || match[2]).toLowerCase();
                                if (term.startsWith('-') && term.length > 1) {
                                    negativeTerms.push(term.substring(1));
                                } else {
                                    const datePattern = /^\d{1,2}\/\d{1,2}(\/\d{2,4})?$/;
                                    if (datePattern.test(term) && !dateCriteria) {
                                        const parsedDates = parseSearchDate(term);
                                        if (parsedDates && parsedDates.length > 0) {
                                            dateCriteria = parsedDates;
                                            continue;
                                        }
                                    }
                                    positiveTerms.push(term);
                                }
                            }
                        }
                    }
                    
                    filtered = filtered.filter(shift => {
                        if (dateCriteria && dateCriteria.length > 0) {
                            if (!shift.dateString) return false;
                            const matchesDate = dateCriteria.some(searchDate => 
                                searchDate.toDateString() === shift.dateString
                            );
                            if (!matchesDate) return false;
                        }
                        
                        for (const [field, value] of Object.entries(fieldCriteria)) {
                            if (field === 'name') {
                                if (!shift.name || !shift.name.toLowerCase().includes(value)) return false;
                            } else if (field === 'role') {
                                if (!shift.role || !shift.role.toLowerCase().includes(value)) return false;
                            } else if (field === 'venue') {
                                if (!shift.venue || !shift.venue.toLowerCase().includes(value)) return false;
                            }
                        }
                        
                        if (positiveTerms.length > 0 || negativeTerms.length > 0 || orTerms.length > 0) {
                            for (const term of negativeTerms) {
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (matchesTerm) return false;
                            }
                            
                            if (orTerms.length > 0) {
                                const matchesAnyOrTerm = orTerms.some(term => {
                                    return (shift.name && shift.name.toLowerCase().includes(term)) ||
                                        (shift.role && shift.role.toLowerCase().includes(term)) ||
                                        (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                        (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                });
                                if (!matchesAnyOrTerm) return false;
                            }
                            
                            for (const term of positiveTerms) {
                                if (term === 'assigned') {
                                    if (!shift.isAssigned) return false;
                                    continue;
                                }
                                if (term === 'unassigned') {
                                    if (shift.isAssigned) return false;
                                    continue;
                                }
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (!matchesTerm) return false;
                            }
                        }
                        
                        return true;
                    });
                }
            }
            
            // My Shifts filter (matches name or role, supports multiple OR logic)
            if (myShiftsFilter) {
                const filterTerm = myShiftsFilter.trim();
                
                // Check if this contains OR logic
                if (/\sOR\s/i.test(filterTerm)) {
                    // Split by OR and collect all terms
                    const orParts = filterTerm.split(/\s+OR\s+/i);
                    const orTerms = [];
                    for (const part of orParts) {
                        const trimmed = part.trim();
                        if (!trimmed) continue;
                        const quoteMatch = trimmed.match(/^"([^"]+)"$/);
                        if (quoteMatch) {
                            orTerms.push(quoteMatch[1].toLowerCase());
                        } else {
                            orTerms.push(trimmed.toLowerCase());
                        }
                    }
                    
                    if (orTerms.length > 0) {
                        filtered = filtered.filter(shift => {
                            return orTerms.some(term => 
                                (shift.name && shift.name.toLowerCase().includes(term)) ||
                                (shift.role && shift.role.toLowerCase().includes(term))
                            );
                        });
                    }
                } else {
                    // Simple single term filter
                    const filterLower = filterTerm.toLowerCase();
                    filtered = filtered.filter(shift => 
                        (shift.name && shift.name.toLowerCase().includes(filterLower)) ||
                        (shift.role && shift.role.toLowerCase().includes(filterLower))
                    );
                }
            }
            
            return filtered;
        }
        
        // Open export modal
        function openExportModal() {
            const modal = document.getElementById('exportModal');
            if (!modal) return;
            
            // Calculate counts for displayed shifts only
            const displayedShifts = getDisplayedShifts();
            document.getElementById('exportDisplayedCount').textContent = displayedShifts.length;
            
            modal.classList.add('show');
        }
        
        // Close export modal
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // ============================================
        // CALENDAR VIEW
        // ============================================
        
        // Color palette for people (will be assigned dynamically)
        const personColorPalette = [
            '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444', 
            '#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#6366f1'
        ];
        let personColorMap = {};
        
        function getPersonColor(name) {
            if (!name) return '#9ca3af';
            if (!personColorMap[name]) {
                const colorIndex = Object.keys(personColorMap).length % personColorPalette.length;
                personColorMap[name] = personColorPalette[colorIndex];
            }
            return personColorMap[name];
        }
        
        function getShiftType(time) {
            if (!time) return { type: 'day', label: 'Day', class: '' };
            const startHour = parseInt(time.split(':')[0]);
            if (startHour >= 5 && startHour < 12) return { type: 'morning', label: 'AM', class: 'shift-morning' };
            if (startHour >= 12 && startHour < 20) return { type: 'afternoon', label: 'PM', class: 'shift-afternoon' };
            return { type: 'night', label: 'Night', class: 'shift-night' };
        }
        
        function openCalendarModal() {
            const shifts = getDisplayedShifts();
            if (shifts.length === 0) {
                alert('No shifts to display.');
                return;
            }
            
            // Reset color map for fresh assignment
            personColorMap = {};
            
            // Group shifts by date, handling overnight shifts that span two days
            const shiftsByDate = {};
            shifts.forEach(s => {
                if (!s.date) return;
                const dateStr = s.date.toISOString().split('T')[0];
                if (!shiftsByDate[dateStr]) shiftsByDate[dateStr] = [];
                
                // Check if this is an overnight shift (end time < start time, but not ending at 00:00)
                let isOvernight = false;
                let startHour = 0, startMin = 0, endHour = 24, endMin = 0;
                if (s.shiftTimeCET) {
                    const timeMatch = s.shiftTimeCET.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                    if (timeMatch) {
                        startHour = parseInt(timeMatch[1]);
                        startMin = parseInt(timeMatch[2]);
                        endHour = parseInt(timeMatch[3]);
                        endMin = parseInt(timeMatch[4]);
                        // Overnight if end < start, but NOT if shift simply ends at midnight (00:00)
                        const endsAtMidnight = endHour === 0 && endMin === 0;
                        isOvernight = endHour < startHour && !endsAtMidnight;
                    }
                }
                
                if (isOvernight) {
                    // Add first part to start date (e.g., 23:45-00:00)
                    shiftsByDate[dateStr].push({
                        ...s,
                        shiftTimeCET: s.shiftTimeCET.split('-')[0].trim() + '-00:00',
                        isOvernightStart: true
                    });
                    
                    // Add second part to next date (e.g., 00:00-07:15)
                    const nextDate = new Date(s.date);
                    nextDate.setDate(nextDate.getDate() + 1);
                    const nextDateStr = nextDate.toISOString().split('T')[0];
                    if (!shiftsByDate[nextDateStr]) shiftsByDate[nextDateStr] = [];
                    shiftsByDate[nextDateStr].push({
                        ...s,
                        shiftTimeCET: '00:00-' + s.shiftTimeCET.split('-')[1].trim(),
                        isOvernightEnd: true
                    });
                } else {
                    shiftsByDate[dateStr].push(s);
                }
            });
            
            // Find date range
            const dates = Object.keys(shiftsByDate).sort();
            if (dates.length === 0) {
                alert('No shifts with valid dates to display.');
                return;
            }
            
            const startDate = new Date(dates[0]);
            const endDate = new Date(dates[dates.length - 1]);
            
            // Get unique people for legend
            const uniquePeople = [...new Set(shifts.map(s => s.name).filter(Boolean))];
            uniquePeople.forEach(name => getPersonColor(name)); // Assign colors
            
            // Calculate first appearance date for each person (for OFF logic)
            const personFirstAppearance = {};
            shifts.forEach(s => {
                if (s.name && s.date) {
                    const dateStr = s.date.toISOString().split('T')[0];
                    if (!personFirstAppearance[s.name] || dateStr < personFirstAppearance[s.name]) {
                        personFirstAppearance[s.name] = dateStr;
                    }
                }
            });
            
            // Render legend
            const legendHtml = uniquePeople.map(name => 
                `<div class="calendar-legend-item">
                    <div class="calendar-legend-color" style="background: ${getPersonColor(name)};"></div>
                    ${name}
                </div>`
            ).join('');
            document.getElementById('calendarLegend').innerHTML = legendHtml;
            
            // Group by month
            const months = {};
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const monthKey = `${d.getFullYear()}-${d.getMonth()}`;
                if (!months[monthKey]) {
                    months[monthKey] = {
                        year: d.getFullYear(),
                        month: d.getMonth(),
                        name: d.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })
                    };
                }
            }
            
            // Render calendar
            let calendarHtml = '';
            
            Object.values(months).forEach(m => {
                calendarHtml += `<div class="calendar-container">
                    <div class="calendar-month-header">${m.name}</div>
                    <div class="calendar-grid">
                        <div class="calendar-day-header">Mon</div>
                        <div class="calendar-day-header">Tue</div>
                        <div class="calendar-day-header">Wed</div>
                        <div class="calendar-day-header">Thu</div>
                        <div class="calendar-day-header">Fri</div>
                        <div class="calendar-day-header">Sat</div>
                        <div class="calendar-day-header">Sun</div>`;
                
                const firstDay = new Date(m.year, m.month, 1);
                const lastDay = new Date(m.year, m.month + 1, 0);
                let startDow = firstDay.getDay();
                startDow = startDow === 0 ? 6 : startDow - 1; // Adjust for Monday start
                
                // Empty cells before first day
                for (let i = 0; i < startDow; i++) {
                    calendarHtml += `<div class="calendar-day-cell empty"></div>`;
                }
                
                // Days of month
                for (let d = 1; d <= lastDay.getDate(); d++) {
                    const dateStr = `${m.year}-${String(m.month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                    const dayOfWeek = new Date(m.year, m.month, d).getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    const dayShifts = shiftsByDate[dateStr] || [];
                    
                    calendarHtml += `<div class="calendar-day-cell ${isWeekend ? 'weekend' : ''}">
                        <div class="calendar-day-number">${d}</div>`;
                    
                    // Sort shifts by time, with overnight continuations first and overnight starts last
                    dayShifts.sort((a, b) => {
                        // Overnight end shifts (00:00-XX:XX continuation from previous day) come first
                        if (a.isOvernightEnd && !b.isOvernightEnd) return -1;
                        if (b.isOvernightEnd && !a.isOvernightEnd) return 1;
                        
                        // Overnight start shifts (XX:XX-00:00 going into next day) come last
                        if (a.isOvernightStart && !b.isOvernightStart) return 1;
                        if (b.isOvernightStart && !a.isOvernightStart) return -1;
                        
                        // Otherwise sort by start time
                        const aTime = a.shiftTimeCET || '00:00';
                        const bTime = b.shiftTimeCET || '00:00';
                        const aStart = parseInt(aTime.split(':')[0]);
                        const bStart = parseInt(bTime.split(':')[0]);
                        return aStart - bStart;
                    });
                    
                    dayShifts.forEach(s => {
                        const shiftInfo = getShiftType(s.shiftTimeCET);
                        const bgColor = getPersonColor(s.name);
                        const displayName = s.name ? s.name.split(' ')[0] : '(Unassigned)';
                        
                        // Check if shift is 1 hour or less
                        let isShortShift = false;
                        if (s.shiftTimeCET) {
                            const timeMatch = s.shiftTimeCET.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                            if (timeMatch) {
                                const startMins = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
                                let endMins = parseInt(timeMatch[3]) * 60 + parseInt(timeMatch[4]);
                                // Handle overnight (end < start means next day)
                                if (endMins < startMins) endMins += 24 * 60;
                                const durationMins = endMins - startMins;
                                isShortShift = durationMins <= 60;
                            }
                        }
                        const shortClass = isShortShift ? ' shift-short' : '';
                        
                        calendarHtml += `<div class="calendar-shift ${shiftInfo.class}${shortClass}" style="background: ${bgColor};">
                            <span class="calendar-shift-name">${displayName}</span>
                            <span class="calendar-shift-time">${s.shiftTimeCET || ''}</span>
                            ${s.role ? `<span class="calendar-shift-role">${s.role}</span>` : ''}
                        </div>`;
                    });
                    
                    // Show OFF for people not scheduled on this day (starting 4 days before first appearance)
                    if (dayShifts.length > 0) {
                        const scheduledPeople = dayShifts.map(s => s.name).filter(Boolean);
                        uniquePeople.forEach(person => {
                            if (!scheduledPeople.includes(person)) {
                                // Only show OFF if within 4 days before or after first appearance
                                const firstAppearance = personFirstAppearance[person];
                                if (firstAppearance) {
                                    const firstDate = new Date(firstAppearance);
                                    const currentDate = new Date(dateStr);
                                    const daysDiff = Math.floor((currentDate - firstDate) / (1000 * 60 * 60 * 24));
                                    // Show OFF if current date is >= 4 days before first appearance
                                    if (daysDiff >= -4) {
                                        const displayName = person.split(' ')[0];
                                        calendarHtml += `<div class="calendar-shift shift-off">
                                            <span class="calendar-shift-name">${displayName}</span>
                                            <span class="calendar-shift-time">OFF</span>
                                        </div>`;
                                    }
                                }
                            }
                        });
                    }
                    
                    calendarHtml += `</div>`;
                }
                
                // Fill remaining cells
                const totalCells = startDow + lastDay.getDate();
                const remaining = (7 - (totalCells % 7)) % 7;
                for (let i = 0; i < remaining; i++) {
                    calendarHtml += `<div class="calendar-day-cell empty"></div>`;
                }
                
                calendarHtml += `</div></div>`;
            });
            
            document.getElementById('calendarContent').innerHTML = calendarHtml;
            document.getElementById('calendarModal').classList.add('show');
        }
        
        function closeCalendarModal() {
            document.getElementById('calendarModal').classList.remove('show');
        }
        
        // Close calendar modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('calendarModal');
            if (modal && e.target === modal) {
                closeCalendarModal();
            }
        });
        
        // Export shifts to ICS file
        function exportShifts() {
            const shiftsToExport = getDisplayedShifts();
            
            if (shiftsToExport.length === 0) {
                alert('No shifts to export.');
                return;
            }
            
            // Get the selected showAs value (BUSY or FREE)
            const showAsRadio = document.querySelector('input[name="showAs"]:checked');
            const showAsBusy = !showAsRadio || showAsRadio.value === 'BUSY';
            
            // Generate ICS content
            const icsContent = generateICSContent(shiftsToExport, showAsBusy);
            
            // Create and download file
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            // Generate filename with date
            const today = new Date();
            const dateStr = today.getFullYear().toString() +
                String(today.getMonth() + 1).padStart(2, '0') +
                String(today.getDate()).padStart(2, '0');
            link.download = `MyCO26Shifts_${dateStr}.ics`;
            
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            // Close modal
            closeExportModal();
            
            debug.log('Exported', shiftsToExport.length, 'shifts to ICS file');
        }
        
        // Export shifts to Excel file
        function exportToExcel() {
            const shiftsToExport = getDisplayedShifts();
            
            if (shiftsToExport.length === 0) {
                alert('No shifts to export.');
                return;
            }
            
            // Format data for Excel - simple readable format
            const excelData = shiftsToExport.map(shift => {
                // Format date as readable string
                const dateStr = shift.date ? 
                    shift.date.toLocaleDateString('en-GB', { weekday: 'short', day: '2-digit', month: 'short', year: 'numeric' }) : '';
                
                return {
                    'Date': dateStr,
                    'Time (CET)': shift.shiftTimeCET || '',
                    'Name': shift.name || '(Unassigned)',
                    'Venue': shift.venue || '',
                    'Location': shift.location || '',
                    'Role': shift.role || '',
                    'Type': shift.shiftType || ''
                };
            });
            
            // Create worksheet and workbook
            const worksheet = XLSX.utils.json_to_sheet(excelData);
            
            // Set column widths for better readability
            worksheet['!cols'] = [
                { wch: 18 },  // Date
                { wch: 12 },  // Time
                { wch: 25 },  // Name
                { wch: 20 },  // Venue
                { wch: 25 },  // Location
                { wch: 25 },  // Role
                { wch: 15 }   // Type
            ];
            
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'My Shifts');
            
            // Generate filename with date
            const today = new Date();
            const dateStr = today.getFullYear().toString() +
                String(today.getMonth() + 1).padStart(2, '0') +
                String(today.getDate()).padStart(2, '0');
            const filename = `MyCO26Shifts_${dateStr}.xlsx`;
            
            // Write and download
            XLSX.writeFile(workbook, filename);
            
            // Close modal
            closeExportModal();
            
            debug.log('Exported', shiftsToExport.length, 'shifts to Excel file');
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('exportModal');
            if (modal && e.target === modal) {
                closeExportModal();
            }
        });
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeExportModal();
            }
        });
        
        // ============================================
        // DOM ELEMENT REFERENCES
        // ============================================
        
        const fileInput = document.getElementById('fileInput');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const appContainer = document.getElementById('appContainer');
        const fileName = document.getElementById('fileName');
        const savedDataInfo = document.getElementById('savedDataInfo');
        const loadSavedDataBtn = document.getElementById('loadSavedDataBtn');
        const content = document.getElementById('content');
        const searchInput = document.getElementById('searchInput');
        const savedSearchInput = document.getElementById('savedSearchInput');
        const executeSavedSearchBtn = document.getElementById('executeSavedSearch');
        const searchInfoBtn = document.getElementById('searchInfoBtn');
        const searchTooltip = document.getElementById('searchTooltip');
        const myNameInput = document.getElementById('myNameInput');
        const myShiftsBtn = document.getElementById('myShiftsBtn');
        const stats = document.getElementById('stats');
        
        // ============================================
        // LOCAL STORAGE & DATA PERSISTENCE
        // ============================================
        
        // LocalStorage functions (works with file:// protocol unlike cookies)
        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, value);
                debug.log('Saved to localStorage:', key, '=', value);
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }
        
        function getFromStorage(key) {
            try {
                const value = localStorage.getItem(key);
                debug.log('Retrieved from localStorage:', key, '=', value);
                return value;
            } catch (e) {
                console.error('Error reading from localStorage:', e);
                return null;
            }
        }
        
        // Load saved search from localStorage on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedSearch = getFromStorage('savedSearch');
            if (savedSearch && savedSearchInput) {
                savedSearchInput.value = savedSearch;
            }
        });
        
        // Also load immediately in case DOMContentLoaded already fired
        const savedSearchImmediate = getFromStorage('savedSearch');
        if (savedSearchImmediate && savedSearchInput) {
            savedSearchInput.value = savedSearchImmediate;
        }
        
        // Track current file name for saving
        let currentFileName = '';
        
        // Save last file info to localStorage
        function saveLastFileInfo() {
            if (currentFileName && lastUpdateTime) {
                const fileInfo = {
                    fileName: currentFileName,
                    lastUpdate: lastUpdateTime,
                    savedAt: new Date().toISOString()
                };
                saveToStorage('lastFileInfo', JSON.stringify(fileInfo));
                debug.log('Saved file info:', fileInfo);
            }
        }
        
        // Check for saved file info and show button on page load
        function checkSavedFileInfo() {
            const savedInfo = getFromStorage('lastFileInfo');
            if (savedInfo) {
                try {
                    const info = JSON.parse(savedInfo);
                    const savedFileRow = document.getElementById('savedFileRow');
                    const savedFileName = document.getElementById('savedFileName');
                    const savedFileInfo = document.getElementById('savedFileInfo');
                    
                    if (savedFileRow && info.fileName) {
                        savedFileRow.style.display = 'block';
                        savedFileName.textContent = info.fileName;
                        
                        // Format last update time - show actual date/time
                        if (info.lastUpdate) {
                            // info.lastUpdate could be a CET string like "07/11/2025 18:15 CET" or an ISO date
                            let displayTime = info.lastUpdate;
                            
                            // If it's an ISO date string, format it nicely
                            if (info.lastUpdate.includes('T') || info.lastUpdate.includes('-')) {
                                const updateDate = new Date(info.lastUpdate);
                                if (!isNaN(updateDate.getTime())) {
                                    const day = String(updateDate.getDate()).padStart(2, '0');
                                    const month = String(updateDate.getMonth() + 1).padStart(2, '0');
                                    const year = updateDate.getFullYear();
                                    const hours = String(updateDate.getHours()).padStart(2, '0');
                                    const minutes = String(updateDate.getMinutes()).padStart(2, '0');
                                    displayTime = `${day}/${month}/${year} ${hours}:${minutes}`;
                                }
                            }
                            
                            savedFileInfo.textContent = `Updated: ${displayTime}`;
                        }
                    }
                } catch (e) {
                    console.error('Error parsing saved file info:', e);
                }
            }
        }
        
        // Initialize saved file info display
        checkSavedFileInfo();
        
        // Functions to save and load shift data
        function saveShiftData() {
            try {
                const dataToSave = {
                    shifts: allShifts,
                    lastUpdate: lastUpdateTime,
                    savedAt: new Date().toISOString()
                };
                saveToStorage('shiftData', JSON.stringify(dataToSave));
                debug.log('Shift data saved:', allShifts.length, 'shifts');
            } catch (e) {
                console.error('Error saving shift data:', e);
            }
        }
        
        function loadShiftData() {
            try {
                const savedData = getFromStorage('shiftData');
                if (!savedData) {
                    return false;
                }
                
                const data = JSON.parse(savedData);
                allShifts = data.shifts || [];
                lastUpdateTime = data.lastUpdate || null;
                
                // Convert date strings back to Date objects and pre-compute dateString
                allShifts.forEach(shift => {
                    if (shift.date && typeof shift.date === 'string') {
                        shift.date = new Date(shift.date);
                    }
                    // Ensure dateString is computed (for data saved before this optimization)
                    if (shift.date && !shift.dateString) {
                        shift.dateString = shift.date.toDateString();
                    }
                });
                
                debug.log('Shift data loaded:', allShifts.length, 'shifts');
                
                // Update UI
                updateLastUpdateDisplay();
                updateFilters();
                renderShifts();
                
                // Show the app
                fileInputContainer.style.display = 'none';
                appContainer.style.display = 'block';
                
                return true;
            } catch (e) {
                console.error('Error loading shift data:', e);
                return false;
            }
        }
        
        // Check for saved data on page load
        function checkSavedData() {
            const savedData = getFromStorage('shiftData');
            const chooseFileLabel = document.getElementById('chooseFileLabel');
            
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    const shiftCount = data.shifts ? data.shifts.length : 0;
                    
                    // Calculate file age and determine color
                    let ageColor = '#059669'; // Green by default
                    let ageIcon = '‚úì';
                    let isStale = false;
                    let ageText = '';
                    
                    if (data.lastUpdate) {
                        // Parse the CET time string (format: "07/11/2025 18:15 CET")
                        const match = data.lastUpdate.match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})/);
                        if (match) {
                            const day = parseInt(match[1]);
                            const month = parseInt(match[2]);
                            const year = parseInt(match[3]);
                            const hour = parseInt(match[4]);
                            const minute = parseInt(match[5]);
                            
                            const isoString = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00+01:00`;
                            const updateDateCET = new Date(isoString);
                            const now = new Date();
                            const hoursDiff = (now - updateDateCET) / (1000 * 60 * 60);
                            
                            if (hoursDiff < 24) {
                                ageColor = '#059669'; // Green
                                ageIcon = '‚úì';
                                ageText = Math.floor(hoursDiff) + 'h ago';
                                if (hoursDiff < 1) ageText = '< 1h ago';
                            } else if (hoursDiff < 48) {
                                ageColor = '#d97706'; // Yellow/Orange
                                ageIcon = '‚ö†Ô∏è';
                                ageText = Math.floor(hoursDiff / 24) + ' day ago';
                                isStale = true;
                            } else {
                                ageColor = '#dc2626'; // Red
                                ageIcon = '‚ùå';
                                ageText = Math.floor(hoursDiff / 24) + ' days ago';
                                isStale = true;
                            }
                        }
                        
                        // Build display with colored age - two lines
                        if (savedDataInfo) {
                            savedDataInfo.innerHTML = `
                                <div style="color: ${ageColor}; font-weight: 600;">${ageIcon} ${data.lastUpdate} (${ageText})</div>
                                <div style="color: var(--slate);">${shiftCount} shifts</div>
                            `;
                        }
                    } else {
                        // Fallback to savedAt if lastUpdate not available
                        const savedAt = new Date(data.savedAt);
                        if (savedDataInfo) {
                            savedDataInfo.innerHTML = `
                                <div>Saved: ${savedAt.toLocaleString()}</div>
                                <div style="color: var(--slate);">${shiftCount} shifts</div>
                            `;
                        }
                    }
                    
                    // Show the saved data row
                    const savedDataRow = document.getElementById('savedDataRow');
                    if (savedDataRow) savedDataRow.style.display = 'block';
                    
                    // Highlight Choose/Refresh button if data is stale
                    if (chooseFileLabel && isStale) {
                        chooseFileLabel.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                        chooseFileLabel.style.animation = 'pulse 2s infinite';
                    }
                } catch (e) {
                    console.error('Error checking saved data:', e);
                }
            }
        }
        
        checkSavedData();
        
        // ============================================
        // DATE PARSING UTILITIES
        // ============================================
        
        function parseSearchDate(dateStr) {
            debug.log('=== parseSearchDate called with:', dateStr);
            // Parse date from search with smart EU/US format detection
            // Supports: dd/mm, mm/dd, dd/mm/yy, mm/dd/yy, dd/mm/yyyy, mm/dd/yyyy
            const parts = dateStr.split('/');
            if (parts.length < 2 || parts.length > 3) {
                debug.log('Invalid date format:', dateStr, '- need 2 or 3 parts');
                return null;
            }
            
            const num1 = parseInt(parts[0]);
            const num2 = parseInt(parts[1]);
            let year = parts.length === 3 ? parseInt(parts[2]) : null;
            
            if (isNaN(num1) || isNaN(num2)) {
                debug.log('Invalid numbers in date:', dateStr);
                return null;
            }
            
            debug.log('Parsing date:', dateStr, '-> num1:', num1, 'num2:', num2, 'year:', year);
            
            // Handle year
            let yearProvided = year !== null;
            if (yearProvided) {
                // Handle 2-digit year: YY format
                if (year < 100) {
                    year = year < 50 ? 2000 + year : 1900 + year;
                }
                debug.log('Year provided:', year);
            } else {
                debug.log('No year provided, will infer based on month');
            }
            
            // Function to infer year based on month
            const inferYear = (month) => {
                if (month >= 11 && month <= 12) return 2025;
                if (month >= 1 && month <= 3) return 2026;
                return new Date().getFullYear();
            };
            
            const possibleDates = [];
            
            // Try DD/MM (European format)
            if (num1 >= 1 && num1 <= 31 && num2 >= 1 && num2 <= 12) {
                const day = num1;
                const month = num2;
                const useYear = yearProvided ? year : inferYear(month);
                const date = new Date(useYear, month - 1, day);
                debug.log('Trying DD/MM:', day + '/' + month + '/' + useYear);
                if (date.getDate() === day && date.getMonth() === month - 1) {
                    debug.log('  Valid!');
                    possibleDates.push(date);
                } else {
                    debug.log('  Invalid date');
                }
            }
            
            // Try MM/DD (US format)
            if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                const month = num1;
                const day = num2;
                const useYear = yearProvided ? year : inferYear(month);
                const date = new Date(useYear, month - 1, day);
                debug.log('Trying MM/DD:', month + '/' + day + '/' + useYear);
                if (date.getDate() === day && date.getMonth() === month - 1) {
                    debug.log('  Valid!');
                    possibleDates.push(date);
                } else {
                    debug.log('  Invalid date');
                }
            }
            
            debug.log('Possible dates found:', possibleDates.length, possibleDates.map(d => d.toDateString()));
            return possibleDates.length > 0 ? possibleDates : null;
        }
        
        function updateLastUpdateDisplay() {
            const displayElement = document.getElementById('lastUpdateDisplay');
            if (!displayElement || !lastUpdateTime) return;
            
            // Parse the CET time string (format: "07/11/2025 18:15 CET")
            const match = lastUpdateTime.match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})/);
            if (!match) {
                displayElement.textContent = '(Last update: ' + lastUpdateTime + ')';
                return;
            }
            
            const day = parseInt(match[1]);
            const month = parseInt(match[2]);
            const year = parseInt(match[3]);
            const hour = parseInt(match[4]);
            const minute = parseInt(match[5]);
            
            // Create date in CET timezone with proper DST handling
            // Use ISO 8601 format with +01:00 timezone offset for CET
            // Note: This assumes standard CET (UTC+1). For CEST (summer), it would be +02:00
            // However, the Excel file should indicate which timezone it's using
            // For now, we'll use +01:00 as the base and let the browser handle it
            const isoString = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00+01:00`;
            const updateDateCET = new Date(isoString);
            
            // Get current time
            const now = new Date();
            const hoursDiff = (now - updateDateCET) / (1000 * 60 * 60);
            
            // Determine color based on age (bright colors for dark navy background)
            let color;
            let backgroundColor;
            let icon = '';
            let tooltip = '';
            
            if (hoursDiff < 24) {
                color = '#10b981'; // Bright green
                backgroundColor = 'rgba(16, 185, 129, 0.15)';
                icon = '‚úì';
                tooltip = 'File is up to date (updated within 24 hours)';
            } else if (hoursDiff < 48) {
                color = '#fbbf24'; // Bright yellow/amber
                backgroundColor = 'rgba(251, 191, 36, 0.15)';
                icon = '‚ö†Ô∏è';
                tooltip = 'File is 24-48 hours old. Consider checking for a more recent version.';
            } else {
                color = '#fb7185'; // Lighter red/rose for better contrast
                backgroundColor = 'rgba(251, 113, 133, 0.15)';
                icon = '‚ùå';
                tooltip = 'File is more than 48 hours old! Please check for a more recent version.';
            }
            
            displayElement.style.color = color;
            displayElement.style.backgroundColor = backgroundColor;
            displayElement.style.padding = '4px 12px';
            displayElement.style.borderRadius = '6px';
            displayElement.style.fontWeight = hoursDiff >= 48 ? '700' : '500';
            displayElement.style.borderBottom = '1px dotted ' + color;
            displayElement.style.transition = 'all 0.2s ease';
            displayElement.title = tooltip;
            displayElement.textContent = icon + ' (Last update: ' + lastUpdateTime + ')';
            if (hoursDiff >= 48) {
                displayElement.classList.add('last-update-flash');
                if (lastUpdateFlashTimeout) {
                    clearTimeout(lastUpdateFlashTimeout);
                }
                lastUpdateFlashTimeout = setTimeout(() => {
                    displayElement.classList.remove('last-update-flash');
                    lastUpdateFlashTimeout = null;
                }, 5000);
            } else {
                displayElement.classList.remove('last-update-flash');
                if (lastUpdateFlashTimeout) {
                    clearTimeout(lastUpdateFlashTimeout);
                    lastUpdateFlashTimeout = null;
                }
            }
            
            // Add hover effect to make it clear there's a tooltip
            displayElement.onmouseenter = function() {
                this.style.opacity = '1';
                this.style.transform = 'translateY(-1px)';
            };
            displayElement.onmouseleave = function() {
                this.style.opacity = '0.9';
                this.style.transform = 'translateY(0)';
            };
        }
        
        // ============================================
        // EVENT HANDLERS & UI INTERACTIONS
        // ============================================
        
        fileInput.addEventListener('change', handleFileSelect);
        
        // Debounced search input (200ms delay)
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                renderShifts();
            }, 200);
        });
        
        // Search info tooltip (hover only)
        if (searchInfoBtn && searchTooltip) {
            searchInfoBtn.addEventListener('mouseenter', () => {
                searchTooltip.style.display = 'block';
            });
            searchInfoBtn.addEventListener('mouseleave', () => {
                searchTooltip.style.display = 'none';
            });
        }
        
        // My Name info tooltip (hover only)
        const myNameInfoBtn = document.getElementById('myNameInfoBtn');
        const myNameTooltip = document.getElementById('myNameTooltip');
        if (myNameInfoBtn && myNameTooltip) {
            myNameInfoBtn.addEventListener('mouseenter', () => {
                myNameTooltip.style.display = 'block';
            });
            myNameInfoBtn.addEventListener('mouseleave', () => {
                myNameTooltip.style.display = 'none';
            });
        }
        
        // Saved Search info tooltip (hover only)
        const savedSearchInfoBtn = document.getElementById('savedSearchInfoBtn');
        const savedSearchTooltip = document.getElementById('savedSearchTooltip');
        if (savedSearchInfoBtn && savedSearchTooltip) {
            savedSearchInfoBtn.addEventListener('mouseenter', () => {
                savedSearchTooltip.style.display = 'block';
            });
            savedSearchInfoBtn.addEventListener('mouseleave', () => {
                savedSearchTooltip.style.display = 'none';
            });
        }
        
        // My Shifts functionality
        if (myNameInput && myShiftsBtn) {
            // Load saved name from localStorage
            const savedName = getFromStorage('myShiftsName');
            if (savedName) {
                myNameInput.value = savedName;
                myShiftsBtn.disabled = false;
                myShiftsBtn.style.opacity = '1';
                myShiftsBtn.style.cursor = 'pointer';
            }
            
            // Enable/disable button based on input
            myNameInput.addEventListener('input', () => {
                const hasValue = myNameInput.value.trim().length > 0;
                myShiftsBtn.disabled = !hasValue;
                myShiftsBtn.style.opacity = hasValue ? '1' : '0.5';
                myShiftsBtn.style.cursor = hasValue ? 'pointer' : 'not-allowed';
                
                // If name changed and filter was active, turn off filter and reset button
                if (myShiftsFilter && myShiftsFilter !== myNameInput.value.trim()) {
                    myShiftsFilter = '';
                    myShiftsBtn.style.background = '#f3f4f6';
                    myNameInput.style.color = '#9ca3af';
                    renderShifts();
                }
                
                // Save to localStorage
                if (hasValue) {
                    saveToStorage('myShiftsName', myNameInput.value.trim());
                }
            });
            
            // Apply My Shifts filter (toggle on/off)
            myShiftsBtn.addEventListener('click', () => {
                if (myNameInput.value.trim()) {
                    if (myShiftsFilter === myNameInput.value.trim()) {
                        // Filter is already active with this name - turn it off
                        myShiftsFilter = '';
                        myNameInput.style.color = '#9ca3af';
                        highlightUnsetButton(myShiftsBtn);
                        debug.log('My Shifts filter turned OFF');
                    } else {
                        // Turn filter on - clear search boxes first
                        myShiftsFilter = myNameInput.value.trim();
                        myShiftsBtn.style.background = '#667eea';
                        myNameInput.style.color = '#000000';
                        
                        // Clear the main search box
                        searchInput.value = '';
                        
                        // Reset Execute Saved Search button if it was active
                        if (executeSavedSearchBtn && executeSavedSearchBtn.style.background === 'rgb(102, 126, 234)') {
                            highlightUnsetButton(executeSavedSearchBtn);
                        }
                        
                        debug.log('My Shifts filter applied:', myShiftsFilter);
                    }
                    renderShifts();
                }
            });
            
            // Clear filter when input is cleared
            myNameInput.addEventListener('keyup', (e) => {
                if (e.key === 'Escape' || myNameInput.value.trim() === '') {
                    myShiftsFilter = '';
                    renderShifts();
                }
            });
        }
        
        // Saved search functionality
        if (savedSearchInput) {
            // Enable/disable Execute Saved Search button based on input
            savedSearchInput.addEventListener('input', () => {
                const hasValue = savedSearchInput.value.trim().length > 0;
                executeSavedSearchBtn.disabled = !hasValue;
                executeSavedSearchBtn.style.opacity = hasValue ? '1' : '0.5';
                executeSavedSearchBtn.style.cursor = hasValue ? 'pointer' : 'not-allowed';
                
                saveToStorage('savedSearch', savedSearchInput.value);
            });
            
            // Initialize button state based on saved search
            const initialValue = savedSearchInput.value.trim();
            if (initialValue) {
                // Has saved value - enable button
                executeSavedSearchBtn.disabled = false;
                executeSavedSearchBtn.style.opacity = '1';
                executeSavedSearchBtn.style.cursor = 'pointer';
            } else {
                // Empty - disable button
                executeSavedSearchBtn.disabled = true;
                executeSavedSearchBtn.style.opacity = '0.5';
                executeSavedSearchBtn.style.cursor = 'not-allowed';
            }
        }
        
        if (executeSavedSearchBtn) {
            executeSavedSearchBtn.addEventListener('click', () => {
                if (savedSearchInput && savedSearchInput.value.trim()) {
                    // Check if already active (search box has the saved search)
                    if (searchInput.value === savedSearchInput.value.trim()) {
                        // Clear the search - change color FIRST
                        highlightUnsetButton(executeSavedSearchBtn);
                        searchInput.value = '';
                        // Force a small delay to ensure color change is visible
                        setTimeout(() => renderShifts(), 0);
                    } else {
                        // Apply the saved search - change color FIRST
                        executeSavedSearchBtn.classList.remove('button-unset-transition', 'button-unset-complete');
                        executeSavedSearchBtn.style.background = '#667eea';
                        searchInput.value = savedSearchInput.value.trim();
                        // Force a small delay to ensure color change is visible
                        setTimeout(() => renderShifts(), 0);
                    }
                }
            });
        }
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                renderShifts();
            });
        });
        
        // ============================================
        // EXCEL FILE PARSING
        // ============================================
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            debug.log('File selected:', file.name);
            fileName.textContent = file.name;
            currentFileName = file.name; // Save for localStorage
            
            // Show loading overlay
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.add('active');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                // Use setTimeout to allow the loading overlay to render before blocking XLSX parsing
                setTimeout(() => {
                try {
                    debug.log('File read successfully, size:', e.total, 'bytes');
                    const data = new Uint8Array(e.target.result);
                    
                    debug.log('Parsing Excel workbook...');
                    const workbook = XLSX.read(data, { type: 'array' });
                    debug.log('Workbook sheets:', workbook.SheetNames);
                    
                    let processedSheet = '';
                    let lastError = null;
                    
                    for (const sheetName of workbook.SheetNames) {
                        // Only process the "COLE - Published Shifts" sheet
                        if (sheetName !== 'COLE - Published Shifts') {
                            debug.log(`Skipping sheet "${sheetName}" - only processing "COLE - Published Shifts"`);
                            continue;
                        }
                        
                        const worksheet = workbook.Sheets[sheetName];
                        debug.log('Processing sheet:', sheetName);
                        debug.log('Worksheet range:', worksheet['!ref']);
                        
                        try {
                            // First, get the raw data to see the actual structure
                            const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                            debug.log('Raw sheet data (first 5 rows):', rawData.slice(0, 5));
                            
                            const jsonData = rawData;
                            debug.log('Parsed JSON data (first 5 rows as arrays):', jsonData.slice(0, 5));
                            
                            debug.log('\n=== RAW DATA STRUCTURE ===');
                            for (let i = 0; i < Math.min(5, jsonData.length); i++) {
                                debug.log(`Row ${i} (${jsonData[i].length} columns):`, jsonData[i]);
                            }
                            
                            if (jsonData.length === 0) {
                                throw new Error('No data found in the Excel file');
                            }
                            
                            // Find the actual header row (skip metadata rows)
                            let actualHeaderRowIndex = -1;
                            const maxHeaderScan = Math.min(jsonData.length, 200);
                            for (let i = 0; i < maxHeaderScan; i++) {
                                const row = jsonData[i];
                                const normalizedCells = row.map(cell => cell ? cell.toString().trim().toUpperCase() : '');
                                const headerMatches = normalizedCells.filter(cell => ['DATE', 'SHIFT (CET)', 'VENUE', 'ROLE', 'NAME'].includes(cell));
                                if (headerMatches.length >= 3) {
                                    actualHeaderRowIndex = i;
                                    debug.log(`Potential header row at ${i} with matches:`, headerMatches);
                                    break;
                                }
                            }

                            if (actualHeaderRowIndex === -1) {
                                throw new Error(`Could not locate the header row in sheet "${sheetName}". Please double-check the COLE template.`);
                            }
                            
                            debug.log('Using row', actualHeaderRowIndex, 'as headers');
                            
                            // Extract last update time from any metadata row before the headers
                            let lastUpdateStr = '';
                            for (let i = 0; i < actualHeaderRowIndex && !lastUpdateStr; i++) {
                                const row = jsonData[i];
                                for (let j = 0; j < row.length; j++) {
                                    const cellValue = row[j];
                                    if (cellValue && cellValue.toString().includes('Last update:')) {
                                        lastUpdateStr = cellValue.toString().replace('Last update:', '').trim();
                                        break;
                                    }
                                }
                            }

                            if (lastUpdateStr) {
                                debug.log('Last update:', lastUpdateStr);
                                lastUpdateTime = lastUpdateStr;
                                updateLastUpdateDisplay();
                            }
                            
                            const headers = jsonData[actualHeaderRowIndex].map(h => h ? h.toString().trim() : '');
                            debug.log('Detected headers:', headers);
                            const normalizedHeaders = headers.map(h => h ? h.toString().trim().toUpperCase() : '');
                            const looksLikeCOLE = normalizedHeaders.includes('DATE') && normalizedHeaders.includes('ROLE');
                            if (looksLikeCOLE) {
                                const requiredCOLEHeaders = ['DATE', 'SHIFT (CET)', 'VENUE', 'ROLE', 'NAME'];
                                const missingHeaders = requiredCOLEHeaders.filter(required => !normalizedHeaders.includes(required));
                                if (missingHeaders.length > 0) {
                                    throw new Error(`The Excel file is missing required COLE columns: ${missingHeaders.join(', ')}`);
                                }
                            }
                            
                            const formattedData = jsonData.slice(actualHeaderRowIndex + 1).map((row, rowIndex) => {
                                const obj = {};
                                headers.forEach((header, i) => {
                                    obj[header] = (i < row.length) ? row[i] : '';
                                    if (i === 0 && rowIndex === 0) {
                                        debug.log('First data cell value:', row[i], 'type:', typeof row[i]);
                                    }
                                });
                                return obj;
                            });
                            
                            debug.log('Formatted data (first 2 rows):', formattedData.slice(0, 2));
                            
                            processData(formattedData);
                            fileInputContainer.style.display = 'none';
                            appContainer.style.display = 'block';
                            processedSheet = sheetName;
                            debug.log('File processing completed using sheet:', sheetName);
                            break;
                        } catch (sheetError) {
                            debug.warn(`Sheet ${sheetName} failed:`, sheetError.message);
                            lastError = sheetError;
                        }
                    }
                    
                    if (!processedSheet) {
                        throw lastError || new Error('No compatible sheet found in the Excel file.');
                    }
                } catch (error) {
                    console.error('Error reading file:', error);
                    console.error('Error stack:', error.stack);
                    fileName.textContent = `Error: ${error.message}`;
                } finally {
                    // Hide loading overlay
                    loadingOverlay.classList.remove('active');
                }
                }, 50); // End setTimeout - delay allows overlay to render
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processCOLEFormat(data, headerRowIndex) {
            debug.log('Processing COLE format...');
            debug.log('Total rows to process:', data.length);
            
            // Data is already formatted as objects with column names as keys
            const keys = Object.keys(data[0]);
            debug.log('Column names:', keys);
            const findColumnKey = (target) =>
                keys.find(key => key && key.toUpperCase() === target);
            const dateKey = findColumnKey('DATE');
            
            if (!dateKey) {
                console.error('Could not find Date column in COLE format data.');
                return;
            }
            
            // Show first 3 data rows for debugging
            debug.log('\n=== FIRST 3 DATA ROWS ===');
            for (let i = 0; i < Math.min(3, data.length); i++) {
                debug.log(`\nRow ${i}:`, data[i]);
            }
            
            allShifts = [];
            
            // Process each row
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                
                // Get the date from the Date column (handles hidden blank leading columns)
                const dateValue = row[dateKey];
                if (!dateValue) continue;
                
                // Convert Excel date serial number to JavaScript Date
                let date;
                if (typeof dateValue === 'number') {
                    // Excel date serial (days since 1900-01-01)
                    date = new Date((dateValue - 25569) * 86400 * 1000);
                } else {
                    date = parseDate(dateValue);
                }
                
                if (!date) continue;
                
                // Look for name, role, venue, location in other columns
                // Common column names: Name, Role, Venue, Location, Time, etc.
                const shift = {
                    date: date,
                    rawDate: date.toISOString().split('T')[0],
                    dateString: date.toDateString(), // Pre-computed for filtering performance
                    isAssigned: false,
                    name: '',
                    role: '',
                    venue: '',
                    location: '',
                    shiftTimeCET: '',
                    shiftTimeIST: '',
                    email: '',
                    professionalPhone: '',
                    rolePhone: '',
                    shiftType: '',
                    meetingRoom: '',
                    pattern: ''
                };
                
                // Map columns to shift properties
                keys.forEach(key => {
                    if (!key) return;
                    const columnName = key.toUpperCase();
                    const value = row[key] ? row[key].toString().trim() : '';
                    
                    if (!value) return;
                    
                    switch(columnName) {
                        case 'NAME':
                            if (value && !value.toLowerCase().includes('unassigned')) {
                                shift.name = value;
                                shift.isAssigned = true;
                            }
                            break;
                        case 'ROLE':
                            shift.role = value;
                            break;
                        case 'VENUE':
                            shift.venue = value;
                            break;
                        case 'LOCATION':
                            shift.location = value;
                            break;
                        case 'SHIFT (CET)':
                            shift.shiftTimeCET = value;
                            break;
                        case '(IST)':
                            shift.shiftTimeIST = value;
                            break;
                        case 'EMAIL':
                            shift.email = value;
                            break;
                        case 'PROFESSIONAL NUMBER':
                        case 'PERSONAL NUMBER':
                            shift.professionalPhone = value;
                            break;
                        case 'ROLE NUMBER':
                            shift.rolePhone = value;
                            break;
                        case 'TYPE':
                            shift.shiftType = value;
                            break;
                    }
                });
                
                allShifts.push(shift);
            }
            
            debug.log('Processed', allShifts.length, 'shifts from COLE format');
            debug.log('Sample shifts:', allShifts.slice(0, 3));
            
            // Save file info to localStorage
            saveLastFileInfo();
            
            updateFilters();
            renderShifts();
        }
        
        function processData(data) {
            debug.log('Processing data...', data);
            
            if (!Array.isArray(data) || data.length === 0) {
                console.error('Invalid data format: Expected an array of rows');
                return;
            }

            // Log the first few rows to see the actual data structure
            debug.log('First 3 rows of data:', data.slice(0, 3));
            
            // Check if this is COLE format by looking at the keys (column names)
            const firstRowKeys = Object.keys(data[0]);
            const normalizedFirstRowKeys = firstRowKeys.map(key => key ? key.toUpperCase() : '');
            const isCOLEFormat = ['DATE', 'VENUE', 'ROLE'].every(column => normalizedFirstRowKeys.includes(column));
            
            debug.log('First row keys:', firstRowKeys);
            debug.log('Is COLE format:', isCOLEFormat);
            
            if (isCOLEFormat) {
                // COLE format: each row is a shift with Date, Venue, Role, Name, etc.
                processCOLEFormat(data, 0);
                return;
            }
            
            // Otherwise, look for NAME-based format (weekly schedule)
            let headerRowIndex = data.findIndex(row => {
                const firstKey = Object.keys(row)[0];
                const value = row[firstKey];
                if (!value) return false;
                const upperValue = value.toString().trim().toUpperCase();
                return upperValue === 'NAME';
            });
            
            debug.log('Header row index for NAME format:', headerRowIndex);
            
            if (headerRowIndex === -1) {
                const firstColumnValues = data.slice(0, 5).map(row => row[Object.keys(row)[0]]);
                debug.log('First column values:', firstColumnValues);
                throw new Error('Could not find the NAME-based header row in the Excel data. Please verify the template has not changed.');
            }
            
            // Get the headers (week ranges)
            const headers = [];
            const nameHeaderRow = data[headerRowIndex];
            const headerKeys = Object.keys(nameHeaderRow);
            
            debug.log('Header keys:', headerKeys);
            
            for (let i = 2; i < headerKeys.length; i++) {
                const header = nameHeaderRow[headerKeys[i]];
                debug.log(`Header ${i}:`, header);
                
                if (header && typeof header === 'string') {
                    const trimmedHeader = header.trim().toUpperCase();
                    if (trimmedHeader !== 'PATTERN') {
                        debug.log('Processing header:', trimmedHeader);
                        const dateRange = parseDateRange(trimmedHeader);
                        debug.log('Parsed date range:', dateRange);
                        
                        headers.push({
                            key: headerKeys[i],
                            label: trimmedHeader,
                            dateRange: dateRange
                        });
                    }
                }
            }
            
            debug.log('Processed headers:', headers);
            
            // Process each person's row
            allShifts = [];
            
            for (let i = headerRowIndex + 1; i < data.length; i++) {
                const row = data[i];
                const name = row[Object.keys(row)[0]];
                const pattern = row[Object.keys(row)[1]];
                
                if (!name || typeof name !== 'string' || name.trim() === '') continue;
                
                // Process each week assignment
                for (const header of headers) {
                    const assignment = row[header.key];
                    if (!assignment || typeof assignment !== 'string') continue;
                    
                    const role = assignment.trim().toUpperCase();
                    if (role !== 'CSM' && role !== 'BACKUP') continue;
                    
                    // Create a shift for each day in the date range
                    const startDate = new Date(header.dateRange.start);
                    const endDate = new Date(header.dateRange.end);
                    
                    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                        // Skip weekends (0 = Sunday, 6 = Saturday)
                        if (d.getDay() === 0 || d.getDay() === 6) continue;
                        
                        const shiftDate = parseDate(d.toISOString().split('T')[0]);
                        allShifts.push({
                            date: shiftDate,
                            name: name.trim(),
                            role: role,
                            pattern: pattern,
                            isAssigned: true,
                            rawDate: d.toISOString().split('T')[0],
                            dateString: shiftDate ? shiftDate.toDateString() : '', // Pre-computed for filtering
                            // For backward compatibility with existing UI
                            venue: 'N/A',
                            location: 'N/A',
                            shiftType: role,
                            shiftTimeCET: '09:00-18:00',
                            shiftTimeIST: '13:30-22:30',
                            email: '',
                            professionalPhone: '',
                            rolePhone: ''
                        });
                    }
                }
            }
            
            // Update UI elements
            updateFilters();
            renderShifts();
            
            debug.log('Processed shifts:', allShifts);
        }
        
        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // If it's already a Date object, return it
            if (dateStr instanceof Date) {
                return new Date(dateStr);
            }
            
            // Handle ISO date strings (from rawDate)
            if (typeof dateStr === 'string' && dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const [year, month, day] = dateStr.split('-').map(Number);
                return new Date(year, month - 1, day);
            }

            // Handle DD/MM/YY format (e.g., "23/10/25")
            const ddmmyyMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if (ddmmyyMatch) {
                const day = parseInt(ddmmyyMatch[1]);
                const month = parseInt(ddmmyyMatch[2]) - 1;
                let year = parseInt(ddmmyyMatch[3]);

                if (year < 100) {
                    year += 2000;
                }

                return new Date(year, month, day);
            }

            // Try parsing as a date object
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return date;
            }

            debug.warn('Could not parse date:', dateStr);
            return null;
        }
        
        function parseDateRange(rangeStr) {
            // Example: 'DEC 2-6' -> { start: Date(2024-12-02), end: Date(2024-12-06) }
            const months = {
                'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,
                'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11
            };
            
            // Handle different date range formats
            const formats = [
                // Format: 'MMM D-D' (same month)
                {
                    regex: /^([A-Z]{3})\s*(\d+)\s*-\s*(\d+)$/i,
                    parse: (match) => {
                        const month = match[1].toUpperCase();
                        const year = new Date().getFullYear() + (months[month] < new Date().getMonth() ? 1 : 0);
                        return {
                            start: new Date(year, months[month], parseInt(match[2])),
                            end: new Date(year, months[month], parseInt(match[3]))
                        };
                    }
                },
                // Format: 'MMM D - MMM D' (cross-month)
                {
                    regex: /^([A-Z]{3})\s*(\d+)\s*-\s*([A-Z]{3})\s*(\d+)$/i,
                    parse: (match) => {
                        const month1 = match[1].toUpperCase();
                        const month2 = match[3].toUpperCase();
                        let year = new Date().getFullYear();
                        
                        // Handle year transition (e.g., DEC 30 - JAN 3)
                        if (months[month1] === 11 && months[month2] === 0) {
                            year++;
                        }
                        
                        return {
                            start: new Date(year, months[month1], parseInt(match[2])),
                            end: new Date(year, months[month2], parseInt(match[4]))
                        };
                    }
                }
            ];
            
            for (const format of formats) {
                const match = rangeStr.match(format.regex);
                if (match) {
                    return format.parse(match);
                }
            }
            
            debug.warn('Could not parse date range:', rangeStr);
            return { start: new Date(), end: new Date() };
        }
        
        function updateFilters() {
            // Update person list
            allPeople = [...new Set(allShifts.map(s => s.name))].filter(Boolean).sort();
        }
        
        // ============================================
        // RENDERING
        // ============================================
        
        function renderShifts() {
            const shiftsContainer = document.getElementById('content');
            const statsElement = document.getElementById('stats');
            
            if (!shiftsContainer || !statsElement) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // Apply filters
            let filtered = [...allShifts];
            
            // Exclude unassigned shifts by default
            if (!includeUnassigned) {
                filtered = filtered.filter(shift => shift.isAssigned);
            }
            
            // Tab filter - use cached dates for performance
            const dates = getCachedDates();
            const { now, today, tomorrow, todayString, tomorrowString } = dates;
            
            switch(currentTab) {
                case 'current':
                    const currentHour = now.getHours();
                    const yesterdayForRender = new Date(now.getTime() - 86400000).toDateString();
                    filtered = filtered.filter(shift => {
                        if (!shift.dateString || !shift.shiftTimeCET) return false;
                        const timeMatch = shift.shiftTimeCET.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                        if (!timeMatch) return false;
                        
                        const startHour = parseInt(timeMatch[1]);
                        const endHour = parseInt(timeMatch[3]);
                        const isOvernight = endHour <= startHour;
                        const isToday = shift.dateString === todayString;
                        const isYesterday = shift.dateString === yesterdayForRender;
                        
                        if (isOvernight) {
                            // Evening portion: shift started today, currently in evening hours
                            if (isToday && currentHour >= startHour) return true;
                            // Morning portion: shift started yesterday, currently before end time
                            if (isYesterday && currentHour < endHour) return true;
                            return false;
                        } else {
                            // Normal shift: must be today and within hours
                            return isToday && currentHour >= startHour && currentHour < endHour;
                        }
                    });
                    break;
                case 'today':
                    filtered = filtered.filter(shift => shift.dateString === todayString);
                    break;
                case 'tomorrow':
                    filtered = filtered.filter(shift => shift.dateString === tomorrowString);
                    break;
                case 'upcoming':
                    filtered = filtered.filter(shift => shift.date && shift.date >= today);
                    break;
            }
            
            // Search filter with field:value support and multiple criteria
            if (searchInput && searchInput.value) {
                const searchTerm = searchInput.value.trim();
                if (searchTerm) {
                    // Parse search into field:value pairs and general terms
                    // Regex: field name, colon, optional space, then at least one non-space character
                    debug.log('Search term:', searchTerm);
                    const fieldMatches = searchTerm.matchAll(/(name|role|venue|date):\s*([^\s]+)/gi);
                    const fieldCriteria = {};
                    let dateCriteria = null;
                    let processedIndices = [];
                    
                    // Extract field:value pairs
                    let matchCount = 0;
                    for (const match of fieldMatches) {
                        matchCount++;
                        debug.log('Match', matchCount, ':', match[0], '-> field:', match[1], 'value:', match[2]);
                        const field = match[1].toLowerCase();
                        const value = match[2];
                        
                        if (field === 'date') {
                            // Parse date with smart format detection
                            const parsedDates = parseSearchDate(value);
                            if (parsedDates && parsedDates.length > 0) {
                                dateCriteria = parsedDates;
                                debug.log('Parsed date search:', value, '->', dateCriteria.map(d => d.toDateString()));
                            } else {
                                debug.warn('Could not parse date:', value);
                            }
                        } else {
                            fieldCriteria[field] = value.toLowerCase();
                        }
                        processedIndices.push({ start: match.index, end: match.index + match[0].length });
                    }
                    
                    // Extract remaining general search terms (not part of field:value)
                    let generalTerms = searchTerm;
                    // Remove field:value pairs from the search string
                    processedIndices.sort((a, b) => b.start - a.start); // Sort in reverse to remove from end first
                    processedIndices.forEach(range => {
                        generalTerms = generalTerms.substring(0, range.start) + generalTerms.substring(range.end);
                    });
                    generalTerms = generalTerms.trim().toLowerCase();
                    
                    // If generalTerms only contains incomplete field:value syntax, ignore it
                    if (generalTerms && /^(name|role|venue|date):\s*$/i.test(generalTerms)) {
                        generalTerms = '';
                    }
                    
                    debug.log('Search criteria:', { fieldCriteria, generalTerms, dateCriteria: dateCriteria ? dateCriteria.length + ' dates' : 'none' });
                    
                    // Parse general terms into positive, negative, and OR terms (do this once, not per shift)
                    let positiveTerms = [];
                    let negativeTerms = [];
                    let orTerms = []; // Array of terms for OR logic (any must match)
                    if (generalTerms) {
                        // Check if the search contains OR logic (case insensitive)
                        // Split by " OR " to handle chains like "term1 OR term2 OR term3"
                        if (/\sOR\s/i.test(generalTerms)) {
                            // This is an OR search - split by OR and collect all terms
                            const orParts = generalTerms.split(/\s+OR\s+/i);
                            for (const part of orParts) {
                                const trimmed = part.trim();
                                if (!trimmed) continue;
                                
                                // Handle quoted phrases
                                const quoteMatch = trimmed.match(/^"([^"]+)"$/);
                                if (quoteMatch) {
                                    orTerms.push(quoteMatch[1].toLowerCase());
                                } else {
                                    orTerms.push(trimmed.toLowerCase());
                                }
                            }
                            debug.log('OR terms:', orTerms);
                        } else {
                            // No OR logic - parse normally
                            const regex = /"([^"]+)"|([^\s]+)/g;
                            let match;
                            while ((match = regex.exec(generalTerms)) !== null) {
                                // match[1] is quoted content, match[2] is unquoted word
                                let term = (match[1] || match[2]).toLowerCase();
                                
                                // Check if term starts with - (negative search)
                                if (term.startsWith('-') && term.length > 1) {
                                    negativeTerms.push(term.substring(1)); // Remove the - prefix
                                } else {
                                    // Check if term looks like a date pattern (e.g., 12/18, 18/12, 12/18/25)
                                    const datePattern = /^\d{1,2}\/\d{1,2}(\/\d{2,4})?$/;
                                    if (datePattern.test(term) && !dateCriteria) {
                                        const parsedDates = parseSearchDate(term);
                                        if (parsedDates && parsedDates.length > 0) {
                                            dateCriteria = parsedDates;
                                            debug.log('Auto-detected date from general term:', term, '->', dateCriteria.map(d => d.toDateString()));
                                            continue; // Don't add to positiveTerms
                                        }
                                    }
                                    positiveTerms.push(term);
                                }
                            }
                        }
                        debug.log('Positive terms:', positiveTerms);
                        debug.log('Negative terms:', negativeTerms);
                        debug.log('OR terms:', orTerms);
                    }
                    
                    // Apply filters
                    filtered = filtered.filter(shift => {
                        // Check date criteria (if specified)
                        if (dateCriteria && dateCriteria.length > 0) {
                            if (!shift.dateString) return false;
                            
                            // Match if shift date matches any of the possible date interpretations
                            // Use pre-computed dateString for performance
                            const matchesDate = dateCriteria.some(searchDate => 
                                searchDate.toDateString() === shift.dateString
                            );
                            if (!matchesDate) return false;
                        }
                        
                        // Check field-specific criteria (all must match)
                        for (const [field, value] of Object.entries(fieldCriteria)) {
                            if (field === 'name') {
                                if (!shift.name || !shift.name.toLowerCase().includes(value)) return false;
                            } else if (field === 'role') {
                                if (!shift.role || !shift.role.toLowerCase().includes(value)) return false;
                            } else if (field === 'venue') {
                                if (!shift.venue || !shift.venue.toLowerCase().includes(value)) return false;
                            }
                        }
                        
                        // Check general terms (positive, negative, and OR terms)
                        if (positiveTerms.length > 0 || negativeTerms.length > 0 || orTerms.length > 0) {
                            
                            // First check negative terms - if any match, exclude this shift
                            for (const term of negativeTerms) {
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (matchesTerm) return false; // Exclude if negative term matches
                            }
                            
                            // Check OR terms - at least one must match
                            if (orTerms.length > 0) {
                                const matchesAnyOrTerm = orTerms.some(term => {
                                    return (shift.name && shift.name.toLowerCase().includes(term)) ||
                                        (shift.role && shift.role.toLowerCase().includes(term)) ||
                                        (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                        (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                });
                                if (!matchesAnyOrTerm) return false; // None of the OR terms matched
                            }
                            
                            // Each positive term must match at least one field (AND across terms)
                            for (const term of positiveTerms) {
                                // Check for assignment status keywords
                                if (term === 'assigned') {
                                    if (!shift.isAssigned) return false;
                                    continue;
                                }
                                if (term === 'unassigned') {
                                    if (shift.isAssigned) return false;
                                    continue;
                                }
                                
                                // Regular field matching
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (!matchesTerm) return false; // If any term doesn't match, exclude this shift
                            }
                        }
                        
                        return true;
                    });
                }
            }
            

            
            // My Shifts filter (AND condition with tab filters, matches name or role, supports multiple OR logic)
            if (myShiftsFilter) {
                const filterTerm = myShiftsFilter.trim();
                
                // Check if this contains OR logic
                if (/\sOR\s/i.test(filterTerm)) {
                    // Split by OR and collect all terms
                    const orParts = filterTerm.split(/\s+OR\s+/i);
                    const orTerms = [];
                    for (const part of orParts) {
                        const trimmed = part.trim();
                        if (!trimmed) continue;
                        const quoteMatch = trimmed.match(/^"([^"]+)"$/);
                        if (quoteMatch) {
                            orTerms.push(quoteMatch[1].toLowerCase());
                        } else {
                            orTerms.push(trimmed.toLowerCase());
                        }
                    }
                    
                    if (orTerms.length > 0) {
                        filtered = filtered.filter(shift => {
                            return orTerms.some(term => 
                                (shift.name && shift.name.toLowerCase().includes(term)) ||
                                (shift.role && shift.role.toLowerCase().includes(term))
                            );
                        });
                    }
                } else {
                    // Simple single term filter
                    const filterLower = filterTerm.toLowerCase();
                    filtered = filtered.filter(shift => 
                        (shift.name && shift.name.toLowerCase().includes(filterLower)) ||
                        (shift.role && shift.role.toLowerCase().includes(filterLower))
                    );
                }
            }
            
            // Person filter
            if (selectedPerson) {
                filtered = filtered.filter(shift => shift.name === selectedPerson);
            }
            
            // Sort by date, then start time, then role, then venue
            filtered.sort((a, b) => {
                // Primary: sort by date
                if (!a.date || !b.date) return 0;
                if (a.date.getTime() !== b.date.getTime()) {
                    return a.date - b.date;
                }
                
                // Secondary: sort by start time (extract from shiftTimeCET like "08:00 - 16:00")
                const getStartHour = (shift) => {
                    if (!shift.shiftTimeCET) return 0;
                    const match = shift.shiftTimeCET.match(/^(\d{1,2}):(\d{2})/);
                    return match ? parseInt(match[1]) * 60 + parseInt(match[2]) : 0;
                };
                const timeA = getStartHour(a);
                const timeB = getStartHour(b);
                if (timeA !== timeB) {
                    return timeA - timeB;
                }
                
                // Tertiary: sort by role name
                const roleA = (a.role || '').toLowerCase();
                const roleB = (b.role || '').toLowerCase();
                if (roleA !== roleB) {
                    return roleA.localeCompare(roleB);
                }
                
                // Quaternary: sort by venue
                const venueA = (a.venue || '').toLowerCase();
                const venueB = (b.venue || '').toLowerCase();
                return venueA.localeCompare(venueB);
            });
            
            // Update stats
            const totalShifts = filtered.length;
            const assignedShifts = filtered.filter(s => s.isAssigned).length;
            const unassignedShifts = filtered.filter(s => !s.isAssigned).length;
            
            // Update stats display as compact inline badges
            // View Calendar button is only active when My Shifts filter is on
            const calendarBtnHtml = myShiftsFilter ?
                '<button class="calendar-view-btn" onclick="openCalendarModal()">' +
                    'üìÖ View Calendar' +
                '</button>' :
                '<button class="calendar-view-btn" style="background: #9ca3af; cursor: not-allowed;" disabled title="Activate My Shifts filter to view calendar">' +
                    'üìÖ View Calendar' +
                '</button>';
            
            const exportButtonHtml = 
                '<button id="exportCalendarBtn" class="export-calendar-btn" onclick="openExportModal()" style="margin-left: 8px;">' +
                    'üì§ Export Shifts' +
                '</button>';
            
            const unassignedBadgeHtml = includeUnassigned ?
                '<label class="stat-badge stat-badge-unassigned" style="cursor: pointer; display: inline-flex; align-items: center; gap: 4px;">' +
                    '<input type="checkbox" checked style="width: 14px; height: 14px; accent-color: var(--olympic-blue); cursor: pointer;" onchange="includeUnassigned=false; renderShifts()">' +
                    'Unassigned: ' + unassignedShifts +
                '</label>' :
                '<label class="stat-badge" style="background: #f3f4f6; color: #6b7280; cursor: pointer; display: inline-flex; align-items: center; gap: 4px;">' +
                    '<input type="checkbox" style="width: 14px; height: 14px; accent-color: var(--olympic-blue); cursor: pointer;" onchange="includeUnassigned=true; renderShifts()">' +
                    'Include Unassigned' +
                '</label>';
            
            statsElement.innerHTML = 
                '<div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">' +
                    '<div>' +
                        '<span class="stat-badge stat-badge-total">Total: ' + totalShifts + '</span>' +
                        '<span class="stat-badge stat-badge-assigned">Assigned: ' + assignedShifts + '</span>' +
                        unassignedBadgeHtml +
                    '</div>' +
                    '<div>' +
                        calendarBtnHtml +
                        exportButtonHtml +
                    '</div>' +
                '</div>';
            
            // Debug logging
            debug.log('Render stats:');
            debug.log('  Tab:', currentTab);
            debug.log('  Total in view:', totalShifts);
            debug.log('  Assigned:', assignedShifts);
            debug.log('  Unassigned:', unassignedShifts);
            debug.log('  Total shifts loaded:', allShifts.length);
            
            // Render shifts using DocumentFragment for better performance
            shiftsContainer.innerHTML = '';
            
            if (filtered.length === 0) {
                shiftsContainer.innerHTML = '<div class="no-results">No shifts found</div>';
                return;
            }
            
            // Limit initial render for performance (show first 300, with "Show more" option)
            const RENDER_LIMIT = 300;
            const showAll = window.showAllShiftsFlag === true;
            const shiftsToRender = showAll ? filtered : filtered.slice(0, RENDER_LIMIT);
            const hasMore = !showAll && filtered.length > RENDER_LIMIT;
            
            // Reset the flag after use (so next filter change goes back to limited view)
            if (showAll) window.showAllShiftsFlag = false;
            
            const fragment = document.createDocumentFragment();
            shiftsToRender.forEach(shift => {
                const shiftElement = document.createElement('div');
                shiftElement.className = 'shift-card';
                
                const dateStr = shift.date ? shift.date.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }) : 'No date';
                
                // Build contact section (horizontal) - escape all user data for XSS protection
                let contactItems = [];
                if (shift.email && !shift.email.toLowerCase().includes('unassigned')) {
                    const safeEmail = escapeHtml(shift.email);
                    const safeEmailAttr = escapeAttr(shift.email);
                    const safeEmailUrl = encodeURIComponent(shift.email);
                    contactItems.push('<a href="msteams:/l/chat/0/0?users=' + safeEmailUrl + '" class="shift-contact-link">üí¨ Teams</a>');
                    contactItems.push('<span class="shift-contact-email">' + safeEmail + '</span>');
                    contactItems.push('<button onclick="copyEmail(\'' + safeEmailAttr + '\', this)" class="shift-copy-btn">üìã Copy</button>');
                }
                if (shift.professionalPhone) {
                    contactItems.push('<span class="shift-contact-phone" title="Individual phone number">üì± Individual: ' + escapeHtml(shift.professionalPhone) + '</span>');
                }
                if (shift.rolePhone) {
                    contactItems.push('<span class="shift-contact-phone" title="Shared role phone (passed between shifts)">üîÑ Role: ' + escapeHtml(shift.rolePhone) + '</span>');
                }
                let contactSection = contactItems.length > 0 ? contactItems.join(' <span class="shift-contact-separator">‚Ä¢</span> ') : '';
                
                // Escape user-provided data for XSS protection
                const safeName = shift.name ? escapeHtml(shift.name) : 'üî¥ Unassigned';
                const safeRole = shift.role ? escapeHtml(shift.role) : 'Unknown Role';
                const safeVenue = escapeHtml(shift.venue);
                const safeLocation = escapeHtml(shift.location);
                const safeTimeCET = escapeHtml(shift.shiftTimeCET);
                const safeTimeIST = escapeHtml(shift.shiftTimeIST);
                const safeType = escapeHtml(shift.shiftType);
                
                shiftElement.innerHTML = 
                    // Header with name and role
                    '<div class="shift-header">' +
                        '<div class="shift-header-info">' +
                            '<div class="shift-name">' + safeName + '</div>' +
                            '<div class="shift-role">' + safeRole + '</div>' +
                        '</div>' +
                        '<div class="shift-badge ' + (shift.isAssigned ? 'badge-assigned' : 'badge-unassigned') + '">' +
                            (shift.isAssigned ? '‚úì Assigned' : '‚ö†Ô∏è Unassigned') +
                        '</div>' +
                    '</div>' +
                    
                    // Grid layout for details
                    '<div class="shift-details">' +
                        '<div class="shift-detail">' +
                            '<div class="shift-detail-label">üìÖ Date</div>' +
                            '<div class="shift-detail-value">' + dateStr + '</div>' +
                        '</div>' +
                        (shift.venue ? 
                            '<div class="shift-detail">' +
                                '<div class="shift-detail-label">üèõÔ∏è Venue</div>' +
                                '<div class="shift-detail-value">' + safeVenue + '</div>' +
                            '</div>' : '') +
                        (shift.location ? 
                            '<div class="shift-detail">' +
                                '<div class="shift-detail-label">üìç Location</div>' +
                                '<div class="shift-detail-value">' + safeLocation + '</div>' +
                            '</div>' : '') +
                        (shift.shiftTimeCET ? 
                            '<div class="shift-detail">' +
                                '<div class="shift-detail-label">‚è∞ Time (CET)</div>' +
                                '<div class="shift-detail-value">' + safeTimeCET + '</div>' +
                            '</div>' : '') +
                        (shift.shiftTimeIST ? 
                            '<div class="shift-detail">' +
                                '<div class="shift-detail-label">‚è∞ Time (IST)</div>' +
                                '<div class="shift-detail-value">' + safeTimeIST + '</div>' +
                            '</div>' : '') +
                        (shift.shiftType ? 
                            '<div class="shift-detail">' +
                                '<div class="shift-detail-label">üíº Type</div>' +
                                '<div class="shift-detail-value">' + safeType + '</div>' +
                            '</div>' : '') +
                    '</div>' +
                    
                    // Contact section (horizontal)
                    (contactSection ? 
                        '<div class="shift-contact">' +
                            '<span class="shift-contact-icon">üìû</span>' +
                            contactSection +
                        '</div>' : '');
                
                fragment.appendChild(shiftElement);
            });
            shiftsContainer.appendChild(fragment);
            
            // Add "Show more" button if there are more shifts
            if (hasMore) {
                const showMoreDiv = document.createElement('div');
                showMoreDiv.className = 'show-more-container';
                showMoreDiv.style.cssText = 'text-align: center; padding: 20px; margin-top: 10px;';
                const remainingCount = filtered.length - RENDER_LIMIT;
                showMoreDiv.innerHTML = 
                    '<button onclick="window.showAllShiftsFlag=true; renderShifts();" style="background: var(--olympic-blue); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem;">' +
                        'üìã Show all ' + filtered.length + ' shifts (' + remainingCount + ' more)' +
                    '</button>' +
                    '<p style="color: var(--slate); font-size: 0.85rem; margin-top: 8px;">Showing first 300 shifts for faster loading</p>';
                shiftsContainer.appendChild(showMoreDiv);
            }
        }
    </script>
</body>
</html>