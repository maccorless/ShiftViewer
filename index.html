<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Milano Cortina 2026 - Shift Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Olympic Winter Theme: Ice blues, deep navy, minimalist elegance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* ============================================
           OLYMPIC WINTER DESIGN SYSTEM
           Milano Cortina 2026
           ============================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            /* Olympic Winter Color Palette */
            --ice-blue: #E3F2FD;
            --sky-blue: #90CAF9;
            --olympic-blue: #1976D2;
            --deep-navy: #0D47A1;
            --silver: #ECEFF1;
            --frost-white: #FAFAFA;
            --snow-white: #FFFFFF;
            --charcoal: #263238;
            --slate: #546E7A;
            --accent-gold: #FFB300;
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;
            
            /* Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.12);
            --shadow-xl: 0 12px 36px rgba(0,0,0,0.15);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--ice-blue) 0%, var(--sky-blue) 100%);
            min-height: 100vh;
            padding: var(--space-lg);
            color: var(--charcoal);
            line-height: 1.6;
            font-size: 15px;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Olympic Header - Deep Navy Gradient */
        .header {
            background: linear-gradient(135deg, var(--deep-navy) 0%, var(--olympic-blue) 100%);
            padding: var(--space-lg) var(--space-xl);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-md);
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }
        
        /* Subtle Olympic rings pattern */
        .header::before {
            content: '';
            position: absolute;
            top: -50px;
            right: -50px;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .header h1 {
            color: var(--snow-white);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: var(--space-sm);
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }
        
        .header p {
            color: rgba(255,255,255,0.9);
            font-size: 1.1rem;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }
        
        /* File Upload Section */
        .file-input-container {
            background: var(--snow-white);
            padding: var(--space-2xl);
            border-radius: var(--radius-lg);
            text-align: center;
            margin-bottom: var(--space-xl);
            box-shadow: var(--shadow-md);
            border: 2px dashed var(--silver);
            transition: all 0.25s ease;
        }
        
        .file-input-container:hover {
            border-color: var(--olympic-blue);
            box-shadow: var(--shadow-lg);
        }
        
        .file-input-container h2 {
            color: var(--charcoal);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: var(--space-sm);
        }
        
        .file-input-container p {
            color: var(--slate);
            margin-bottom: var(--space-lg);
        }
        
        .file-input-container input[type="file"] {
            display: none;
        }
        
        .file-label {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-md) var(--space-xl);
            background: linear-gradient(135deg, var(--olympic-blue), var(--deep-navy));
            color: var(--snow-white);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.25s ease;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }
        
        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .file-label:active {
            transform: translateY(0);
        }
        
        /* Tabs - Olympic Rings Inspired */
        .tabs {
            display: flex;
            gap: var(--space-sm);
            background: var(--snow-white);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            min-width: 120px;
            padding: var(--space-md) var(--space-lg);
            background: transparent;
            border: none;
            color: var(--slate);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s ease;
            font-weight: 500;
            font-size: 0.95rem;
            white-space: nowrap;
        }
        
        .tab:hover {
            background: var(--ice-blue);
            color: var(--olympic-blue);
        }
        
        .tab.active {
            background: linear-gradient(135deg, var(--olympic-blue), var(--deep-navy));
            color: var(--snow-white);
            box-shadow: var(--shadow-sm);
        }
        
        /* Search & Filters Section */
        .search-container {
            background: var(--snow-white);
            padding: var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            box-shadow: var(--shadow-sm);
        }
        
        .search-input {
            flex: 1;
            min-width: 250px;
            padding: var(--space-md);
            border: 2px solid var(--silver);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            font-family: inherit;
            transition: all 0.15s ease;
            background: var(--frost-white);
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--olympic-blue);
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            background: var(--snow-white);
        }
        
        .search-input::placeholder {
            color: var(--slate);
            opacity: 0.6;
        }
        
        .search-help {
            margin-top: 10px;
            font-size: 14px;
            color: #6b7280;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .filter-select {
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .person-select-container {
            position: relative;
            flex: 1;
            min-width: 200px;
        }
        
        .person-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .person-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .person-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .person-dropdown.show {
            display: block;
        }
        
        .person-option {
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .person-option:hover {
            background: #f3f4f6;
        }
        
        .person-option.selected {
            background: #e0e7ff;
            color: #667eea;
            font-weight: 500;
        }
        
        .content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 400px;
        }
        
        /* Shift Cards - Elegant Design */
        .shift-card {
            background: var(--snow-white);
            border-radius: var(--radius-sm);
            padding: 10px 12px;
            margin-bottom: 6px;
            box-shadow: var(--shadow-sm);
            transition: all 0.25s ease;
            border: 1px solid transparent;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .shift-card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
            border-color: var(--olympic-blue);
        }
        
        .shift-card.unassigned {
            border-left: 4px solid var(--accent-gold);
        }
        
        /* Card Header */
        .shift-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: var(--space-md);
            padding-bottom: var(--space-md);
            border-bottom: 2px solid var(--silver);
        }
        
        .shift-name {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--charcoal);
            margin-bottom: var(--space-xs);
        }
        
        .shift-role {
            font-size: 1rem;
            font-weight: 600;
            color: var(--olympic-blue);
        }
        
        .shift-badge {
            padding: var(--space-xs) var(--space-md);
            border-radius: var(--radius-full);
            font-size: 0.8rem;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .badge-assigned {
            background: rgba(67, 160, 71, 0.1);
            color: #2E7D32;
            border: 1px solid rgba(67, 160, 71, 0.3);
        }
        
        .badge-unassigned {
            background: rgba(255, 179, 0, 0.1);
            color: #F57C00;
            border: 1px solid rgba(255, 179, 0, 0.3);
        }
        
        /* Card Details Grid */
        .shift-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }
        
        .shift-detail {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }
        
        .shift-detail strong {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--slate);
            font-weight: 600;
        }
        
        .shift-detail span {
            font-size: 0.95rem;
            color: var(--charcoal);
            font-weight: 500;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        /* Statistics Bar */
        .stats {
            background: var(--snow-white);
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-lg);
            display: flex;
            gap: var(--space-xl);
            align-items: center;
            box-shadow: var(--shadow-sm);
            flex-wrap: wrap;
        }
        
        .stat-card {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .stat-label {
            color: var(--slate);
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .stat-number {
            color: var(--olympic-blue);
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: var(--space-md);
            }
            
            .header {
                padding: var(--space-xl) var(--space-lg);
            }
            
            .header h1 {
                font-size: 1.75rem;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                width: 100%;
            }
            
            .shift-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-sm);
            }
            
            .shift-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="USER_GUIDE.html" target="_blank" style="position: absolute; top: 24px; right: 32px; color: white; text-decoration: none; font-size: 0.9rem; padding: 8px 16px; background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border-radius: 8px; transition: all 0.25s; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; font-weight: 500; border: 1px solid rgba(255,255,255,0.2); z-index: 10;" onmouseover="this.style.background='rgba(255,255,255,0.25)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255,255,255,0.15)'; this.style.transform='translateY(0)'">
                <span>‚ùì</span>
                <span>Help / User Guide</span>
            </a>
            <h1>üèîÔ∏è Milano Cortina 2026 - Shift Viewer <span id="lastUpdateDisplay" style="font-size: 0.5em; font-weight: 400; opacity: 0.9;"></span></h1>
            <p>Olympic shift schedule viewing made simple</p>
        </div>
        
        <div class="file-input-container" id="fileInputContainer">
            <h2>üìä Load Shift Schedule</h2>
            <p>Obtain the latest file from <strong>COLE</strong> ‚Ä¢ Upload Excel file or load previously saved data</p>
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button id="loadSavedDataBtn" class="file-label" style="display: none;">
                    üìÇ Load Saved Data
                </button>
                <label for="fileInput" class="file-label">
                    üìÅ Choose Excel File
                </label>
            </div>
            <input type="file" id="fileInput" accept=".xlsx,.xls" style="display: none;">
            <p id="fileName"></p>
            <p id="savedDataInfo"></p>
        </div>
        
        <div id="appContainer" style="display: none;">
            
            <!-- COMPACT CONTROLS ROW -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); margin-bottom: var(--space-md); box-shadow: var(--shadow-sm);">
                <!-- Tabs -->
                <div class="tabs" style="margin-bottom: 0;">
                    <button class="tab active" data-tab="upcoming">üìã Upcoming</button>
                    <button class="tab" data-tab="current">üî¥ Current</button>
                    <button class="tab" data-tab="today">üìÜ Today</button>
                    <button class="tab" data-tab="tomorrow">üìÖ Tomorrow</button>
                    <button class="tab" data-tab="search">üîç All</button>
                </div>
            </div>
            
            <!-- COMPACT FILTERS ROW -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); margin-bottom: var(--space-md); box-shadow: var(--shadow-sm);">
                <div style="display: grid; grid-template-columns: 1fr auto auto; gap: var(--space-sm); align-items: center;">
                    <!-- Main Search -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input type="text" class="search-input" id="searchInput" placeholder="üîç Search shifts..." style="flex: 1;">
                        <button id="searchInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="Search Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="searchTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 420px; box-shadow: var(--shadow-xl); top: 45px; right: 0; line-height: 1.6;">
                            <strong style="color: var(--sky-blue);">Search Tips:</strong><br>
                            ‚Ä¢ <strong>General:</strong> John (searches name, role, venue, type)<br>
                            ‚Ä¢ <strong>Multiple terms (AND):</strong> wmr olena<br>
                            ‚Ä¢ <strong>Quoted phrase:</strong> "duty manager"<br>
                            ‚Ä¢ <strong>Exclude terms:</strong> -RTOC or venue:TOC -RTOC<br>
                            ‚Ä¢ <strong>Assignment status:</strong> assigned or unassigned<br>
                            ‚Ä¢ <strong>Type search:</strong> virtual or "on site"<br>
                            ‚Ä¢ <strong>Combine filters:</strong> unassigned wmr -virtual<br>
                            ‚Ä¢ <strong>Specific field:</strong> role:WMR<br>
                            ‚Ä¢ <strong>Multiple fields:</strong> name:Olena venue:RTOC<br>
                            ‚Ä¢ <strong>Date search:</strong> date:15/11 or date:11/15<br>
                            &nbsp;&nbsp;(tries both EU and US formats)<br>
                            ‚Ä¢ <strong>Date with year:</strong> date:15/11/2025<br>
                            ‚Ä¢ Year inference: Nov-Dec‚Üí2025, Jan-Mar‚Üí2026<br>
                            ‚Ä¢ All searches are case insensitive<br>
                            ‚Ä¢ Supported fields: name, role, venue, date
                        </div>
                    </div>
                    
                    
                    <!-- My Shifts -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input 
                            type="text" 
                            id="myNameInput" 
                            placeholder="My name"
                            class="search-input"
                            style="width: 150px; color: #9ca3af;"
                        >
                        <button 
                            id="myShiftsBtn" 
                            class="file-label" 
                            style="padding: var(--space-sm) var(--space-md); cursor: not-allowed; opacity: 0.5; background: var(--frost-white); color: var(--charcoal); border: 2px solid var(--silver); white-space: nowrap;"
                            disabled
                        >
                            üë§ My Shifts
                        </button>
                        <button id="myNameInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="My Name Filter Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="myNameTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 300px; box-shadow: var(--shadow-xl); top: 45px; right: 0;">
                            <strong style="color: var(--sky-blue);">My Name Filter:</strong><br>
                            Enter your name and click "My Shifts" to filter shifts assigned to you. Your name is saved across sessions but the filter is deactivated by default. Works with tab filters (e.g., "Upcoming" + "My Shifts" = your upcoming shifts).
                        </div>
                    </div>
                    
                    
                    <!-- Saved Search -->
                    <div style="display: flex; gap: var(--space-sm); align-items: center; position: relative;">
                        <input 
                            type="text" 
                            class="search-input" 
                            id="savedSearchInput" 
                            placeholder="Saved search"
                            style="width: 200px;"
                        >
                        <button class="file-label" id="executeSavedSearch" style="padding: var(--space-sm) var(--space-md); cursor: not-allowed; background: var(--frost-white); color: var(--charcoal); opacity: 0.5; border: 2px solid var(--silver); white-space: nowrap;" disabled>
                            ‚ñ∂Ô∏è Execute
                        </button>
                        <button id="savedSearchInfoBtn" style="background: var(--olympic-blue); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: help; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s;" title="Saved Search Help" onmouseover="this.style.background='var(--deep-navy)'; this.style.transform='scale(1.1)'" onmouseout="this.style.background='var(--olympic-blue)'; this.style.transform='scale(1)'">
                            i
                        </button>
                        <div id="savedSearchTooltip" style="display: none; position: absolute; background: var(--charcoal); color: white; padding: var(--space-md); border-radius: var(--radius-md); font-size: 0.85rem; z-index: 1000; max-width: 300px; box-shadow: var(--shadow-xl); top: 45px; right: 0;">
                            <strong style="color: var(--sky-blue);">Saved Search:</strong><br>
                            Your search is automatically saved across sessions. Click "Execute" to toggle the search on/off. Uses the same powerful search syntax as the main search box.
                    </div>
                </div>
            </div>
            
            <!-- RESULTS -->
            <div style="background: var(--snow-white); padding: var(--space-md); border-radius: var(--radius-md); box-shadow: var(--shadow-sm);">
                <!-- Compact stats header -->
                <div id="stats" style="font-size: 11px; color: var(--slate); margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--silver); display: flex; gap: 8px;"></div>
                <div id="content">
                    <div class="loading">Loading shifts...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allShifts = [];
        let currentTab = 'upcoming';
        let allPeople = [];
        let selectedPerson = '';
        let lastUpdateTime = null;
        let myShiftsFilter = ''; // Name filter for "My Shifts"
        
        // Copy email to clipboard function
        function copyEmail(email, button) {
            navigator.clipboard.writeText(email).then(() => {
                // Store original button content
                const originalHTML = button.innerHTML;
                const originalColor = button.style.color;
                
                // Show success feedback
                button.innerHTML = '‚úì Copied!';
                button.style.color = '#10b981';
                button.style.borderColor = '#10b981';
                button.style.background = '#d1fae5';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.style.color = originalColor;
                    button.style.borderColor = '#d1d5db';
                    button.style.background = 'transparent';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy email:', err);
                button.innerHTML = '‚úó Failed';
                button.style.color = '#ef4444';
                setTimeout(() => {
                    button.innerHTML = 'üìã Copy';
                    button.style.color = '#6b7280';
                }, 2000);
            });
        }
        
        const fileInput = document.getElementById('fileInput');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const appContainer = document.getElementById('appContainer');
        const fileName = document.getElementById('fileName');
        const savedDataInfo = document.getElementById('savedDataInfo');
        const loadSavedDataBtn = document.getElementById('loadSavedDataBtn');
        const content = document.getElementById('content');
        const searchInput = document.getElementById('searchInput');
        const savedSearchInput = document.getElementById('savedSearchInput');
        const executeSavedSearchBtn = document.getElementById('executeSavedSearch');
        const searchInfoBtn = document.getElementById('searchInfoBtn');
        const searchTooltip = document.getElementById('searchTooltip');
        const myNameInput = document.getElementById('myNameInput');
        const myShiftsBtn = document.getElementById('myShiftsBtn');
        const stats = document.getElementById('stats');
        
        // LocalStorage functions (works with file:// protocol unlike cookies)
        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, value);
                console.log('Saved to localStorage:', key, '=', value);
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }
        
        function getFromStorage(key) {
            try {
                const value = localStorage.getItem(key);
                console.log('Retrieved from localStorage:', key, '=', value);
                return value;
            } catch (e) {
                console.error('Error reading from localStorage:', e);
                return null;
            }
        }
        
        // Load saved search from localStorage on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedSearch = getFromStorage('savedSearch');
            if (savedSearch && savedSearchInput) {
                savedSearchInput.value = savedSearch;
            }
        });
        
        // Also load immediately in case DOMContentLoaded already fired
        const savedSearchImmediate = getFromStorage('savedSearch');
        if (savedSearchImmediate && savedSearchInput) {
            savedSearchInput.value = savedSearchImmediate;
        }
        
        // Functions to save and load shift data
        function saveShiftData() {
            try {
                const dataToSave = {
                    shifts: allShifts,
                    lastUpdate: lastUpdateTime,
                    savedAt: new Date().toISOString()
                };
                saveToStorage('shiftData', JSON.stringify(dataToSave));
                console.log('Shift data saved:', allShifts.length, 'shifts');
            } catch (e) {
                console.error('Error saving shift data:', e);
            }
        }
        
        function loadShiftData() {
            try {
                const savedData = getFromStorage('shiftData');
                if (!savedData) return false;
                
                const data = JSON.parse(savedData);
                allShifts = data.shifts || [];
                lastUpdateTime = data.lastUpdate || null;
                
                // Convert date strings back to Date objects
                allShifts.forEach(shift => {
                    if (shift.date && typeof shift.date === 'string') {
                        shift.date = new Date(shift.date);
                    }
                });
                
                console.log('Shift data loaded:', allShifts.length, 'shifts');
                
                // Update UI
                updateLastUpdateDisplay();
                updateFilters();
                renderShifts();
                
                // Show the app
                fileInputContainer.style.display = 'none';
                appContainer.style.display = 'block';
                
                return true;
            } catch (e) {
                console.error('Error loading shift data:', e);
                return false;
            }
        }
        
        // Check for saved data on page load
        function checkSavedData() {
            const savedData = getFromStorage('shiftData');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    const shiftCount = data.shifts ? data.shifts.length : 0;
                    
                    // Show the Excel file's last update time, not when we saved to localStorage
                    let displayText = `Saved data available: ${shiftCount} shifts`;
                    if (data.lastUpdate) {
                        displayText += ` (file updated: ${data.lastUpdate})`;
                    } else {
                        // Fallback to savedAt if lastUpdate not available
                        const savedAt = new Date(data.savedAt);
                        displayText += ` (saved ${savedAt.toLocaleString()})`;
                    }
                    
                    savedDataInfo.textContent = displayText;
                    loadSavedDataBtn.style.display = 'inline-block';
                } catch (e) {
                    console.error('Error checking saved data:', e);
                }
            }
        }
        
        checkSavedData();
        
        function parseSearchDate(dateStr) {
            console.log('=== parseSearchDate called with:', dateStr);
            // Parse date from search with smart EU/US format detection
            // Supports: dd/mm, mm/dd, dd/mm/yy, mm/dd/yy, dd/mm/yyyy, mm/dd/yyyy
            const parts = dateStr.split('/');
            if (parts.length < 2 || parts.length > 3) {
                console.log('Invalid date format:', dateStr, '- need 2 or 3 parts');
                return null;
            }
            
            const num1 = parseInt(parts[0]);
            const num2 = parseInt(parts[1]);
            let year = parts.length === 3 ? parseInt(parts[2]) : null;
            
            if (isNaN(num1) || isNaN(num2)) {
                console.log('Invalid numbers in date:', dateStr);
                return null;
            }
            
            console.log('Parsing date:', dateStr, '-> num1:', num1, 'num2:', num2, 'year:', year);
            
            // Handle year
            let yearProvided = year !== null;
            if (yearProvided) {
                // Handle 2-digit year: YY format
                if (year < 100) {
                    year = year < 50 ? 2000 + year : 1900 + year;
                }
                console.log('Year provided:', year);
            } else {
                console.log('No year provided, will infer based on month');
            }
            
            // Function to infer year based on month
            const inferYear = (month) => {
                if (month >= 11 && month <= 12) return 2025;
                if (month >= 1 && month <= 3) return 2026;
                return new Date().getFullYear();
            };
            
            const possibleDates = [];
            
            // Try DD/MM (European format)
            if (num1 >= 1 && num1 <= 31 && num2 >= 1 && num2 <= 12) {
                const day = num1;
                const month = num2;
                const useYear = yearProvided ? year : inferYear(month);
                const date = new Date(useYear, month - 1, day);
                console.log('Trying DD/MM:', day + '/' + month + '/' + useYear);
                if (date.getDate() === day && date.getMonth() === month - 1) {
                    console.log('  Valid!');
                    possibleDates.push(date);
                } else {
                    console.log('  Invalid date');
                }
            }
            
            // Try MM/DD (US format)
            if (num1 >= 1 && num1 <= 12 && num2 >= 1 && num2 <= 31) {
                const month = num1;
                const day = num2;
                const useYear = yearProvided ? year : inferYear(month);
                const date = new Date(useYear, month - 1, day);
                console.log('Trying MM/DD:', month + '/' + day + '/' + useYear);
                if (date.getDate() === day && date.getMonth() === month - 1) {
                    console.log('  Valid!');
                    possibleDates.push(date);
                } else {
                    console.log('  Invalid date');
                }
            }
            
            console.log('Possible dates found:', possibleDates.length, possibleDates.map(d => d.toDateString()));
            return possibleDates.length > 0 ? possibleDates : null;
        }
        
        function updateLastUpdateDisplay() {
            const displayElement = document.getElementById('lastUpdateDisplay');
            if (!displayElement || !lastUpdateTime) return;
            
            // Parse the CET time string (format: "07/11/2025 18:15 CET")
            const match = lastUpdateTime.match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2})/);
            if (!match) {
                displayElement.textContent = '(Last update: ' + lastUpdateTime + ')';
                return;
            }
            
            const day = parseInt(match[1]);
            const month = parseInt(match[2]) - 1; // JS months are 0-indexed
            const year = parseInt(match[3]);
            const hour = parseInt(match[4]);
            const minute = parseInt(match[5]);
            
            // Create date in CET timezone (UTC+1 or UTC+2 depending on DST)
            // For simplicity, we'll assume CET is UTC+1
            const updateDate = new Date(Date.UTC(year, month, day, hour - 1, minute));
            
            // Get current time
            const now = new Date();
            const hoursDiff = (now - updateDate) / (1000 * 60 * 60);
            
            // Determine color based on age (bright colors for dark navy background)
            let color;
            let backgroundColor;
            let icon = '';
            let tooltip = '';
            
            if (hoursDiff < 24) {
                color = '#10b981'; // Bright green
                backgroundColor = 'rgba(16, 185, 129, 0.15)';
                icon = '‚úì';
                tooltip = 'File is up to date (updated within 24 hours)';
            } else if (hoursDiff < 48) {
                color = '#fbbf24'; // Bright yellow/amber
                backgroundColor = 'rgba(251, 191, 36, 0.15)';
                icon = '‚ö†Ô∏è';
                tooltip = 'File is 24-48 hours old. Consider checking for a more recent version.';
            } else {
                color = '#fb7185'; // Lighter red/rose for better contrast
                backgroundColor = 'rgba(251, 113, 133, 0.15)';
                icon = '‚ùå';
                tooltip = 'File is more than 48 hours old! Please check for a more recent version.';
            }
            
            displayElement.style.color = color;
            displayElement.style.backgroundColor = backgroundColor;
            displayElement.style.padding = '4px 12px';
            displayElement.style.borderRadius = '6px';
            displayElement.style.fontWeight = '500';
            displayElement.style.borderBottom = '1px dotted ' + color;
            displayElement.style.transition = 'all 0.2s ease';
            displayElement.title = tooltip;
            displayElement.textContent = icon + ' (Last update: ' + lastUpdateTime + ')';
            
            // Add hover effect to make it clear there's a tooltip
            displayElement.onmouseenter = function() {
                this.style.opacity = '1';
                this.style.transform = 'translateY(-1px)';
            };
            displayElement.onmouseleave = function() {
                this.style.opacity = '0.9';
                this.style.transform = 'translateY(0)';
            };
        }
        
        fileInput.addEventListener('change', handleFileSelect);
        
        if (loadSavedDataBtn) {
            loadSavedDataBtn.addEventListener('click', () => {
                loadShiftData();
            });
        }
        
        // Debounced search input (200ms delay)
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                renderShifts();
            }, 200);
        });
        
        // Search info tooltip (hover only)
        if (searchInfoBtn && searchTooltip) {
            searchInfoBtn.addEventListener('mouseenter', () => {
                searchTooltip.style.display = 'block';
            });
            searchInfoBtn.addEventListener('mouseleave', () => {
                searchTooltip.style.display = 'none';
            });
        }
        
        // My Name info tooltip (hover only)
        const myNameInfoBtn = document.getElementById('myNameInfoBtn');
        const myNameTooltip = document.getElementById('myNameTooltip');
        if (myNameInfoBtn && myNameTooltip) {
            myNameInfoBtn.addEventListener('mouseenter', () => {
                myNameTooltip.style.display = 'block';
            });
            myNameInfoBtn.addEventListener('mouseleave', () => {
                myNameTooltip.style.display = 'none';
            });
        }
        
        // Saved Search info tooltip (hover only)
        const savedSearchInfoBtn = document.getElementById('savedSearchInfoBtn');
        const savedSearchTooltip = document.getElementById('savedSearchTooltip');
        if (savedSearchInfoBtn && savedSearchTooltip) {
            savedSearchInfoBtn.addEventListener('mouseenter', () => {
                savedSearchTooltip.style.display = 'block';
            });
            savedSearchInfoBtn.addEventListener('mouseleave', () => {
                savedSearchTooltip.style.display = 'none';
            });
        }
        
        // My Shifts functionality
        if (myNameInput && myShiftsBtn) {
            // Load saved name from localStorage
            const savedName = getFromStorage('myShiftsName');
            if (savedName) {
                myNameInput.value = savedName;
                myShiftsBtn.disabled = false;
                myShiftsBtn.style.opacity = '1';
                myShiftsBtn.style.cursor = 'pointer';
            }
            
            // Enable/disable button based on input
            myNameInput.addEventListener('input', () => {
                const hasValue = myNameInput.value.trim().length > 0;
                myShiftsBtn.disabled = !hasValue;
                myShiftsBtn.style.opacity = hasValue ? '1' : '0.5';
                myShiftsBtn.style.cursor = hasValue ? 'pointer' : 'not-allowed';
                
                // If name changed and filter was active, turn off filter and reset button
                if (myShiftsFilter && myShiftsFilter !== myNameInput.value.trim()) {
                    myShiftsFilter = '';
                    myShiftsBtn.style.background = '#f3f4f6';
                    myNameInput.style.color = '#9ca3af';
                    renderShifts();
                }
                
                // Save to localStorage
                if (hasValue) {
                    saveToStorage('myShiftsName', myNameInput.value.trim());
                }
            });
            
            // Apply My Shifts filter (toggle on/off)
            myShiftsBtn.addEventListener('click', () => {
                if (myNameInput.value.trim()) {
                    if (myShiftsFilter === myNameInput.value.trim()) {
                        // Filter is already active with this name - turn it off
                        myShiftsFilter = '';
                        myShiftsBtn.style.background = '#f3f4f6';
                        myNameInput.style.color = '#9ca3af';
                        console.log('My Shifts filter turned OFF');
                    } else {
                        // Turn filter on - clear search boxes first
                        myShiftsFilter = myNameInput.value.trim();
                        myShiftsBtn.style.background = '#667eea';
                        myNameInput.style.color = '#000000';
                        
                        // Clear the main search box
                        searchInput.value = '';
                        
                        // Reset Execute Saved Search button if it was active
                        if (executeSavedSearchBtn && executeSavedSearchBtn.style.background === 'rgb(102, 126, 234)') {
                            executeSavedSearchBtn.style.background = '#f3f4f6';
                        }
                        
                        console.log('My Shifts filter applied:', myShiftsFilter);
                    }
                    renderShifts();
                }
            });
            
            // Clear filter when input is cleared
            myNameInput.addEventListener('keyup', (e) => {
                if (e.key === 'Escape' || myNameInput.value.trim() === '') {
                    myShiftsFilter = '';
                    renderShifts();
                }
            });
        }
        
        // Saved search functionality
        if (savedSearchInput) {
            // Enable/disable Execute Saved Search button based on input
            savedSearchInput.addEventListener('input', () => {
                const hasValue = savedSearchInput.value.trim().length > 0;
                executeSavedSearchBtn.disabled = !hasValue;
                executeSavedSearchBtn.style.opacity = hasValue ? '1' : '0.5';
                executeSavedSearchBtn.style.cursor = hasValue ? 'pointer' : 'not-allowed';
                
                saveToStorage('savedSearch', savedSearchInput.value);
            });
            
            // Initialize button state based on saved search
            const initialValue = savedSearchInput.value.trim();
            if (initialValue) {
                // Has saved value - enable button
                executeSavedSearchBtn.disabled = false;
                executeSavedSearchBtn.style.opacity = '1';
                executeSavedSearchBtn.style.cursor = 'pointer';
            } else {
                // Empty - disable button
                executeSavedSearchBtn.disabled = true;
                executeSavedSearchBtn.style.opacity = '0.5';
                executeSavedSearchBtn.style.cursor = 'not-allowed';
            }
        }
        
        if (executeSavedSearchBtn) {
            executeSavedSearchBtn.addEventListener('click', () => {
                if (savedSearchInput && savedSearchInput.value.trim()) {
                    // Check if already active (search box has the saved search)
                    if (searchInput.value === savedSearchInput.value.trim()) {
                        // Clear the search - change color FIRST
                        executeSavedSearchBtn.style.background = '#f3f4f6';
                        searchInput.value = '';
                        // Force a small delay to ensure color change is visible
                        setTimeout(() => renderShifts(), 0);
                    } else {
                        // Apply the saved search - change color FIRST
                        executeSavedSearchBtn.style.background = '#667eea';
                        searchInput.value = savedSearchInput.value.trim();
                        // Force a small delay to ensure color change is visible
                        setTimeout(() => renderShifts(), 0);
                    }
                }
            });
        }
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                renderShifts();
            });
        });
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('File selected:', file.name);
            fileName.textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    console.log('File read successfully, size:', e.total, 'bytes');
                    const data = new Uint8Array(e.target.result);
                    
                    console.log('Parsing Excel workbook...');
                    const workbook = XLSX.read(data, { type: 'array' });
                    console.log('Workbook sheets:', workbook.SheetNames);
                    
                    const firstSheetName = workbook.SheetNames[0];
                    console.log('Using sheet:', firstSheetName);
                    
                    const worksheet = workbook.Sheets[firstSheetName];
                    console.log('Worksheet range:', worksheet['!ref']);
                    
                    // First, get the raw data to see the actual structure
                    const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                    console.log('Raw sheet data (first 5 rows):', rawData.slice(0, 5));
                    
                    // Try with header: 1 to get array of arrays first
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                    console.log('Parsed JSON data (first 5 rows as arrays):', jsonData.slice(0, 5));
                    
                    // Show the structure more clearly
                    console.log('\n=== RAW DATA STRUCTURE ===');
                    for (let i = 0; i < Math.min(5, jsonData.length); i++) {
                        console.log(`Row ${i} (${jsonData[i].length} columns):`, jsonData[i]);
                    }
                    
                    if (jsonData.length === 0) {
                        throw new Error('No data found in the Excel file');
                    }
                    
                    // Find the actual header row (skip metadata rows)
                    let actualHeaderRowIndex = 0;
                    for (let i = 0; i < Math.min(5, jsonData.length); i++) {
                        const row = jsonData[i];
                        // Look for a row that has 'Date' in first column and other meaningful headers
                        if (row[0] && row[0].toString().toUpperCase() === 'DATE' && row.length > 5) {
                            actualHeaderRowIndex = i;
                            break;
                        }
                    }
                    
                    console.log('Using row', actualHeaderRowIndex, 'as headers');
                    
                    // Extract last update time from row 0 if it exists
                    let lastUpdateStr = '';
                    if (jsonData[0] && jsonData[0][0]) {
                        const firstCell = jsonData[0][0].toString();
                        if (firstCell.includes('Last update:')) {
                            lastUpdateStr = firstCell.replace('Last update:', '').trim();
                            console.log('Last update:', lastUpdateStr);
                            lastUpdateTime = lastUpdateStr;
                            updateLastUpdateDisplay();
                        }
                    }
                    
                    // Convert array of arrays to array of objects
                    const headers = jsonData[actualHeaderRowIndex].map(h => h ? h.toString().trim() : '');
                    console.log('Detected headers:', headers);
                    
                    const formattedData = jsonData.slice(actualHeaderRowIndex + 1).map((row, rowIndex) => {
                        const obj = {};
                        headers.forEach((header, i) => {
                            obj[header] = (i < row.length) ? row[i] : '';
                            // If it's the first column and first row after header, log it for debugging
                            if (i === 0 && rowIndex === 0) {
                                console.log('First data cell value:', row[i], 'type:', typeof row[i]);
                            }
                        });
                        return obj;
                    });
                    
                    console.log('Formatted data (first 2 rows):', formattedData.slice(0, 2));
                    
                    // Process the data
                    processData(formattedData);
                    
                    // Show the app interface
                    fileInputContainer.style.display = 'none';
                    appContainer.style.display = 'block';
                    
                    console.log('File processing completed');
                } catch (error) {
                    console.error('Error reading file:', error);
                    console.error('Error stack:', error.stack);
                    fileName.textContent = `Error: ${error.message}`;
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processCOLEFormat(data, headerRowIndex) {
            console.log('Processing COLE format...');
            console.log('Total rows to process:', data.length);
            
            // Data is already formatted as objects with column names as keys
            const keys = Object.keys(data[0]);
            console.log('Column names:', keys);
            
            // Show first 3 data rows for debugging
            console.log('\n=== FIRST 3 DATA ROWS ===');
            for (let i = 0; i < Math.min(3, data.length); i++) {
                console.log(`\nRow ${i}:`, data[i]);
            }
            
            allShifts = [];
            
            // Process each row
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                
                // Get the date from first column
                const dateValue = row[keys[0]];
                if (!dateValue) continue;
                
                // Convert Excel date serial number to JavaScript Date
                let date;
                if (typeof dateValue === 'number') {
                    // Excel date serial (days since 1900-01-01)
                    date = new Date((dateValue - 25569) * 86400 * 1000);
                } else {
                    date = parseDate(dateValue);
                }
                
                if (!date) continue;
                
                // Look for name, role, venue, location in other columns
                // Common column names: Name, Role, Venue, Location, Time, etc.
                const shift = {
                    date: date,
                    rawDate: date.toISOString().split('T')[0],
                    isAssigned: false,
                    name: '',
                    role: '',
                    venue: '',
                    location: '',
                    shiftTimeCET: '',
                    shiftTimeIST: '',
                    email: '',
                    professionalPhone: '',
                    rolePhone: '',
                    shiftType: '',
                    meetingRoom: '',
                    pattern: ''
                };
                
                // Map columns to shift properties
                keys.forEach(key => {
                    const columnName = key.toUpperCase();
                    const value = row[key] ? row[key].toString().trim() : '';
                    
                    if (!value) return;
                    
                    switch(columnName) {
                        case 'NAME':
                            if (value && !value.includes('Unassigned')) {
                                shift.name = value;
                                shift.isAssigned = true;
                            }
                            break;
                        case 'ROLE':
                            shift.role = value;
                            break;
                        case 'VENUE':
                            shift.venue = value;
                            break;
                        case 'LOCATION':
                            shift.location = value;
                            break;
                        case 'SHIFT (CET)':
                            shift.shiftTimeCET = value;
                            break;
                        case '(IST)':
                            shift.shiftTimeIST = value;
                            break;
                        case 'EMAIL':
                            shift.email = value;
                            break;
                        case 'PROFESSIONAL NUMBER':
                            shift.professionalPhone = value;
                            break;
                        case 'ROLE NUMBER':
                            shift.rolePhone = value;
                            break;
                        case 'TYPE':
                            shift.shiftType = value;
                            break;
                    }
                });
                
                allShifts.push(shift);
            }
            
            console.log('Processed', allShifts.length, 'shifts from COLE format');
            console.log('Sample shifts:', allShifts.slice(0, 3));
            
            updateFilters();
            renderShifts();
            
            // Save data to localStorage
            saveShiftData();
        }
        
        function processData(data) {
            console.log('Processing data...', data);
            
            if (!Array.isArray(data) || data.length === 0) {
                console.error('Invalid data format: Expected an array of rows');
                return;
            }

            // Log the first few rows to see the actual data structure
            console.log('First 3 rows of data:', data.slice(0, 3));
            
            // Check if this is COLE format by looking at the keys (column names)
            const firstRowKeys = Object.keys(data[0]);
            const isCOLEFormat = firstRowKeys.includes('Date') && firstRowKeys.includes('Venue') && firstRowKeys.includes('Role');
            
            console.log('First row keys:', firstRowKeys);
            console.log('Is COLE format:', isCOLEFormat);
            
            if (isCOLEFormat) {
                // COLE format: each row is a shift with Date, Venue, Role, Name, etc.
                processCOLEFormat(data, 0);
                return;
            }
            
            // Otherwise, look for NAME-based format (weekly schedule)
            let headerRowIndex = data.findIndex(row => {
                const firstKey = Object.keys(row)[0];
                const value = row[firstKey];
                if (!value) return false;
                const upperValue = value.toString().trim().toUpperCase();
                return upperValue === 'NAME';
            });
            
            console.log('Header row index for NAME format:', headerRowIndex);
            
            if (headerRowIndex === -1) {
                console.error('Could not find header row in Excel data.');
                console.log('First column values:', data.slice(0, 5).map(row => row[Object.keys(row)[0]]));
                return;
            }
            
            // Get the headers (week ranges)
            const headers = [];
            const nameHeaderRow = data[headerRowIndex];
            const headerKeys = Object.keys(nameHeaderRow);
            
            console.log('Header keys:', headerKeys);
            
            for (let i = 2; i < headerKeys.length; i++) {
                const header = nameHeaderRow[headerKeys[i]];
                console.log(`Header ${i}:`, header);
                
                if (header && typeof header === 'string') {
                    const trimmedHeader = header.trim().toUpperCase();
                    if (trimmedHeader !== 'PATTERN') {
                        console.log('Processing header:', trimmedHeader);
                        const dateRange = parseDateRange(trimmedHeader);
                        console.log('Parsed date range:', dateRange);
                        
                        headers.push({
                            key: headerKeys[i],
                            label: trimmedHeader,
                            dateRange: dateRange
                        });
                    }
                }
            }
            
            console.log('Processed headers:', headers);
            
            // Process each person's row
            allShifts = [];
            
            for (let i = headerRowIndex + 1; i < data.length; i++) {
                const row = data[i];
                const name = row[Object.keys(row)[0]];
                const pattern = row[Object.keys(row)[1]];
                
                if (!name || typeof name !== 'string' || name.trim() === '') continue;
                
                // Process each week assignment
                for (const header of headers) {
                    const assignment = row[header.key];
                    if (!assignment || typeof assignment !== 'string') continue;
                    
                    const role = assignment.trim().toUpperCase();
                    if (role !== 'CSM' && role !== 'BACKUP') continue;
                    
                    // Create a shift for each day in the date range
                    const startDate = new Date(header.dateRange.start);
                    const endDate = new Date(header.dateRange.end);
                    
                    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                        // Skip weekends (0 = Sunday, 6 = Saturday)
                        if (d.getDay() === 0 || d.getDay() === 6) continue;
                        
                        allShifts.push({
                            date: parseDate(d.toISOString().split('T')[0]),
                            name: name.trim(),
                            role: role,
                            pattern: pattern,
                            isAssigned: true,
                            rawDate: d.toISOString().split('T')[0],
                            // For backward compatibility with existing UI
                            venue: 'N/A',
                            location: 'N/A',
                            shiftType: role,
                            shiftTimeCET: '09:00-18:00',
                            shiftTimeIST: '13:30-22:30',
                            email: '',
                            professionalPhone: '',
                            rolePhone: ''
                        });
                    }
                }
            }
            
            // Update UI elements
            updateFilters();
            renderShifts();
            
            console.log('Processed shifts:', allShifts);
        }
        
        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // If it's already a Date object, return it
            if (dateStr instanceof Date) {
                return new Date(dateStr);
            }
            
            // Handle ISO date strings (from rawDate)
            if (typeof dateStr === 'string' && dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                const [year, month, day] = dateStr.split('-').map(Number);
                return new Date(year, month - 1, day);
            }

            // Handle DD/MM/YY format (e.g., "23/10/25")
            const ddmmyyMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if (ddmmyyMatch) {
                const day = parseInt(ddmmyyMatch[1]);
                const month = parseInt(ddmmyyMatch[2]) - 1;
                let year = parseInt(ddmmyyMatch[3]);

                if (year < 100) {
                    year += 2000;
                }

                return new Date(year, month, day);
            }

            // Try parsing as a date object
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return date;
            }

            console.warn('Could not parse date:', dateStr);
            return null;
        }
        
        function parseDateRange(rangeStr) {
            // Example: 'DEC 2-6' -> { start: Date(2024-12-02), end: Date(2024-12-06) }
            const months = {
                'JAN': 0, 'FEB': 1, 'MAR': 2, 'APR': 3, 'MAY': 4, 'JUN': 5,
                'JUL': 6, 'AUG': 7, 'SEP': 8, 'OCT': 9, 'NOV': 10, 'DEC': 11
            };
            
            // Handle different date range formats
            const formats = [
                // Format: 'MMM D-D' (same month)
                {
                    regex: /^([A-Z]{3})\s*(\d+)\s*-\s*(\d+)$/i,
                    parse: (match) => {
                        const month = match[1].toUpperCase();
                        const year = new Date().getFullYear() + (months[month] < new Date().getMonth() ? 1 : 0);
                        return {
                            start: new Date(year, months[month], parseInt(match[2])),
                            end: new Date(year, months[month], parseInt(match[3]))
                        };
                    }
                },
                // Format: 'MMM D - MMM D' (cross-month)
                {
                    regex: /^([A-Z]{3})\s*(\d+)\s*-\s*([A-Z]{3})\s*(\d+)$/i,
                    parse: (match) => {
                        const month1 = match[1].toUpperCase();
                        const month2 = match[3].toUpperCase();
                        let year = new Date().getFullYear();
                        
                        // Handle year transition (e.g., DEC 30 - JAN 3)
                        if (months[month1] === 11 && months[month2] === 0) {
                            year++;
                        }
                        
                        return {
                            start: new Date(year, months[month1], parseInt(match[2])),
                            end: new Date(year, months[month2], parseInt(match[4]))
                        };
                    }
                }
            ];
            
            for (const format of formats) {
                const match = rangeStr.match(format.regex);
                if (match) {
                    return format.parse(match);
                }
            }
            
            console.warn('Could not parse date range:', rangeStr);
            return { start: new Date(), end: new Date() };
        }
        
        function updateFilters() {
            // Update person list
            allPeople = [...new Set(allShifts.map(s => s.name))].filter(Boolean).sort();
        }
        
        function applySearch(shifts, searchTerm) {
            // Parse search parameters
            const params = {};
            const paramPattern = /(\w+):([^\s]+|"[^"]+")/g;
            let match;
            let hasParams = false;
            
            while ((match = paramPattern.exec(searchTerm)) !== null) {
                hasParams = true;
                const key = match[1].toLowerCase();
                const value = match[2].replace(/"/g, '').toLowerCase();
                params[key] = value;
            }
            
            if (!hasParams) {
                // Simple text search
                return shifts.filter(shift => 
                    shift.name.toLowerCase().includes(searchTerm) ||
                    shift.role.toLowerCase().includes(searchTerm) ||
                    shift.venue.toLowerCase().includes(searchTerm)
                );
            }
            
            // Parameter-based search
            return shifts.filter(shift => {
                for (const [key, value] of Object.entries(params)) {
                    switch(key) {
                        case 'name':
                            if (!shift.name.toLowerCase().includes(value)) return false;
                            break;
                        case 'venue':
                            if (!shift.venue.toLowerCase().includes(value)) return false;
                            break;
                        case 'role':
                            if (!shift.role.toLowerCase().includes(value)) return false;
                            break;
                        case 'date':
                            const targetDate = parseSearchDate(value);
                            if (targetDate && shift.date) {
                                const shiftDate = new Date(shift.date);
                                if (shiftDate.toDateString() !== targetDate.toDateString()) {
                                    return false;
                                }
                            }
                            break;
                    }
                }
                return true;
            });
        }
        

        
        function renderShifts() {
            const shiftsContainer = document.getElementById('content');
            const statsElement = document.getElementById('stats');
            
            if (!shiftsContainer || !statsElement) {
                console.error('Required DOM elements not found');
                return;
            }
            
            // Apply filters
            let filtered = [...allShifts];
            
            // Tab filter
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            switch(currentTab) {
                case 'current':
                    const currentHour = now.getHours();
                    filtered = filtered.filter(shift => {
                        if (!shift.date) return false;
                        const shiftDate = new Date(shift.date);
                        const isToday = shiftDate.toDateString() === today.toDateString();
                        if (isToday && shift.shiftTimeCET) {
                            const timeMatch = shift.shiftTimeCET.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
                            if (timeMatch) {
                                const startHour = parseInt(timeMatch[1]);
                                const endHour = parseInt(timeMatch[3]);
                                return currentHour >= startHour && currentHour < endHour;
                            }
                        }
                        return false;
                    });
                    break;
                case 'today':
                    filtered = filtered.filter(shift => {
                        if (!shift.date) return false;
                        const shiftDate = new Date(shift.date);
                        return shiftDate.toDateString() === today.toDateString();
                    });
                    break;
                case 'tomorrow':
                    filtered = filtered.filter(shift => {
                        if (!shift.date) return false;
                        const shiftDate = new Date(shift.date);
                        return shiftDate.toDateString() === tomorrow.toDateString();
                    });
                    break;
                case 'upcoming':
                    filtered = filtered.filter(shift => {
                        if (!shift.date) return false;
                        return shift.date >= today;
                    });
                    break;
            }
            
            // Search filter with field:value support and multiple criteria
            if (searchInput && searchInput.value) {
                const searchTerm = searchInput.value.trim();
                if (searchTerm) {
                    // Parse search into field:value pairs and general terms
                    // Regex: field name, colon, optional space, then at least one non-space character
                    console.log('Search term:', searchTerm);
                    const fieldMatches = searchTerm.matchAll(/(name|role|venue|date):\s*([^\s]+)/gi);
                    const fieldCriteria = {};
                    let dateCriteria = null;
                    let processedIndices = [];
                    
                    // Extract field:value pairs
                    let matchCount = 0;
                    for (const match of fieldMatches) {
                        matchCount++;
                        console.log('Match', matchCount, ':', match[0], '-> field:', match[1], 'value:', match[2]);
                        const field = match[1].toLowerCase();
                        const value = match[2];
                        
                        if (field === 'date') {
                            // Parse date with smart format detection
                            const parsedDates = parseSearchDate(value);
                            if (parsedDates && parsedDates.length > 0) {
                                dateCriteria = parsedDates;
                                console.log('Parsed date search:', value, '->', dateCriteria.map(d => d.toDateString()));
                            } else {
                                console.warn('Could not parse date:', value);
                            }
                        } else {
                            fieldCriteria[field] = value.toLowerCase();
                        }
                        processedIndices.push({ start: match.index, end: match.index + match[0].length });
                    }
                    
                    // Extract remaining general search terms (not part of field:value)
                    let generalTerms = searchTerm;
                    // Remove field:value pairs from the search string
                    processedIndices.sort((a, b) => b.start - a.start); // Sort in reverse to remove from end first
                    processedIndices.forEach(range => {
                        generalTerms = generalTerms.substring(0, range.start) + generalTerms.substring(range.end);
                    });
                    generalTerms = generalTerms.trim().toLowerCase();
                    
                    // If generalTerms only contains incomplete field:value syntax, ignore it
                    if (generalTerms && /^(name|role|venue|date):\s*$/i.test(generalTerms)) {
                        generalTerms = '';
                    }
                    
                    console.log('Search criteria:', { fieldCriteria, generalTerms, dateCriteria: dateCriteria ? dateCriteria.length + ' dates' : 'none' });
                    
                    // Parse general terms into positive and negative terms (do this once, not per shift)
                    let positiveTerms = [];
                    let negativeTerms = [];
                    if (generalTerms) {
                        const regex = /"([^"]+)"|([^\s]+)/g;
                        let match;
                        while ((match = regex.exec(generalTerms)) !== null) {
                            // match[1] is quoted content, match[2] is unquoted word
                            let term = (match[1] || match[2]).toLowerCase();
                            
                            // Check if term starts with - (negative search)
                            if (term.startsWith('-') && term.length > 1) {
                                negativeTerms.push(term.substring(1)); // Remove the - prefix
                            } else {
                                positiveTerms.push(term);
                            }
                        }
                        console.log('Positive terms:', positiveTerms);
                        console.log('Negative terms:', negativeTerms);
                    }
                    
                    // Apply filters
                    filtered = filtered.filter(shift => {
                        // Check date criteria (if specified)
                        if (dateCriteria && dateCriteria.length > 0) {
                            if (!shift.date) return false;
                            
                            // Match if shift date matches any of the possible date interpretations
                            const shiftDateStr = shift.date.toDateString();
                            const matchesDate = dateCriteria.some(searchDate => 
                                searchDate.toDateString() === shiftDateStr
                            );
                            if (!matchesDate) return false;
                        }
                        
                        // Check field-specific criteria (all must match)
                        for (const [field, value] of Object.entries(fieldCriteria)) {
                            if (field === 'name') {
                                if (!shift.name || !shift.name.toLowerCase().includes(value)) return false;
                            } else if (field === 'role') {
                                if (!shift.role || !shift.role.toLowerCase().includes(value)) return false;
                            } else if (field === 'venue') {
                                if (!shift.venue || !shift.venue.toLowerCase().includes(value)) return false;
                            }
                        }
                        
                        // Check general terms (positive and negative)
                        if (positiveTerms.length > 0 || negativeTerms.length > 0) {
                            
                            // First check negative terms - if any match, exclude this shift
                            for (const term of negativeTerms) {
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (matchesTerm) return false; // Exclude if negative term matches
                            }
                            
                            // Each positive term must match at least one field (AND across terms)
                            for (const term of positiveTerms) {
                                // Check for assignment status keywords
                                if (term === 'assigned') {
                                    if (!shift.isAssigned) return false;
                                    continue;
                                }
                                if (term === 'unassigned') {
                                    if (shift.isAssigned) return false;
                                    continue;
                                }
                                
                                // Regular field matching
                                const matchesTerm = 
                                    (shift.name && shift.name.toLowerCase().includes(term)) ||
                                    (shift.role && shift.role.toLowerCase().includes(term)) ||
                                    (shift.venue && shift.venue.toLowerCase().includes(term)) ||
                                    (shift.shiftType && shift.shiftType.toLowerCase().includes(term));
                                if (!matchesTerm) return false; // If any term doesn't match, exclude this shift
                            }
                        }
                        
                        return true;
                    });
                }
            }
            

            
            // My Shifts filter (AND condition with tab filters)
            if (myShiftsFilter) {
                filtered = filtered.filter(shift => 
                    shift.name && shift.name.toLowerCase().includes(myShiftsFilter.toLowerCase())
                );
            }
            
            // Person filter
            if (selectedPerson) {
                filtered = filtered.filter(shift => shift.name === selectedPerson);
            }
            
            // Sort by date
            filtered.sort((a, b) => {
                if (!a.date || !b.date) return 0;
                return a.date - b.date;
            });
            
            // Update stats
            const totalShifts = filtered.length;
            const assignedShifts = filtered.filter(s => s.isAssigned).length;
            const unassignedShifts = filtered.filter(s => !s.isAssigned).length;
            
            // Update stats display as compact inline badges
            statsElement.innerHTML = 
                '<span style="background: var(--ice-blue); color: var(--charcoal); padding: 3px 8px; border-radius: 10px; font-weight: 600;">Total: ' + totalShifts + '</span>' +
                '<span style="background: #d1fae5; color: #065f46; padding: 3px 8px; border-radius: 10px; font-weight: 600;">Assigned: ' + assignedShifts + '</span>' +
                '<span style="background: #fef3c7; color: #92400e; padding: 3px 8px; border-radius: 10px; font-weight: 600;">Unassigned: ' + unassignedShifts + '</span>';
            
            // Debug logging
            console.log('Render stats:');
            console.log('  Tab:', currentTab);
            console.log('  Total in view:', totalShifts);
            console.log('  Assigned:', assignedShifts);
            console.log('  Unassigned:', unassignedShifts);
            console.log('  Total shifts loaded:', allShifts.length);
            
            // Render shifts
            shiftsContainer.innerHTML = '';
            
            if (filtered.length === 0) {
                shiftsContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No shifts found</div>';
                return;
            }
            
            filtered.forEach(shift => {
                const shiftElement = document.createElement('div');
                shiftElement.className = 'shift-card';
                
                const dateStr = shift.date ? shift.date.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }) : 'No date';
                
                // Build contact section (horizontal)
                let contactItems = [];
                if (shift.email && !shift.email.includes('Unassigned')) {
                    const emailId = 'email-' + Math.random().toString(36).substr(2, 9);
                    contactItems.push('<a href="msteams:/l/chat/0/0?users=' + shift.email + '" style="color: #667eea; text-decoration: none; font-weight: 500; font-size: 12px;">üí¨ Teams</a>');
                    contactItems.push('<span style="color: #6b7280; font-size: 12px;">' + shift.email + '</span>');
                    contactItems.push('<button onclick="copyEmail(\'' + shift.email + '\', this)" style="background: transparent; border: 1px solid #d1d5db; border-radius: 3px; padding: 1px 5px; cursor: pointer; font-size: 10px; color: #6b7280; transition: all 0.15s; margin-left: 3px;" onmouseover="this.style.background=\'#f3f4f6\'; this.style.borderColor=\'#9ca3af\'" onmouseout="this.style.background=\'transparent\'; this.style.borderColor=\'#d1d5db\'">üìã Copy</button>');
                }
                if (shift.professionalPhone) {
                    contactItems.push('<span style="color: #374151; font-size: 12px;" title="Individual phone number">üì± Individual: ' + shift.professionalPhone + '</span>');
                }
                if (shift.rolePhone) {
                    contactItems.push('<span style="color: #374151; font-size: 12px;" title="Shared role phone (passed between shifts)">üîÑ Role: ' + shift.rolePhone + '</span>');
                }
                let contactSection = contactItems.length > 0 ? contactItems.join(' <span style="color: #d1d5db;">‚Ä¢</span> ') : '';
                
                shiftElement.innerHTML = 
                    // Header with name and role
                    '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #e5e7eb;">' +
                        '<div>' +
                            '<div style="font-size: 17px; font-weight: 700; color: #1f2937; margin-bottom: 1px; line-height: 1.2;">' + (shift.name || 'üî¥ Unassigned') + '</div>' +
                            '<div style="font-size: 14px; color: #667eea; font-weight: 600; line-height: 1.2;">' + (shift.role || 'Unknown Role') + '</div>' +
                        '</div>' +
                        '<div style="background: ' + (shift.isAssigned ? '#10b981' : '#f59e0b') + '; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; line-height: 1.4;">' +
                            (shift.isAssigned ? '‚úì Assigned' : '‚ö†Ô∏è Unassigned') +
                        '</div>' +
                    '</div>' +
                    
                    // Grid layout for details
                    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 4px 16px; margin-bottom: 4px;">' +
                        '<div>' +
                            '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">üìÖ Date</div>' +
                            '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + dateStr + '</div>' +
                        '</div>' +
                        (shift.venue ? 
                            '<div>' +
                                '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">üèõÔ∏è Venue</div>' +
                                '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + shift.venue + '</div>' +
                            '</div>' : '') +
                        (shift.location ? 
                            '<div>' +
                                '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">üìç Location</div>' +
                                '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + shift.location + '</div>' +
                            '</div>' : '') +
                        (shift.shiftTimeCET ? 
                            '<div>' +
                                '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">‚è∞ Time (CET)</div>' +
                                '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + shift.shiftTimeCET + '</div>' +
                            '</div>' : '') +
                        (shift.shiftTimeIST ? 
                            '<div>' +
                                '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">‚è∞ Time (IST)</div>' +
                                '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + shift.shiftTimeIST + '</div>' +
                            '</div>' : '') +
                        (shift.shiftType ? 
                            '<div>' +
                                '<div style="font-size: 10px; text-transform: uppercase; color: #9ca3af; font-weight: 600; margin-bottom: 1px; line-height: 1.3;">üíº Type</div>' +
                                '<div style="font-size: 13px; color: #1f2937; font-weight: 500; line-height: 1.3;">' + shift.shiftType + '</div>' +
                            '</div>' : '') +
                    '</div>' +
                    
                    // Contact section (horizontal)
                    (contactSection ? 
                        '<div style="background: #f9fafb; padding: 5px 8px; border-radius: 4px; border-left: 2px solid #667eea; margin-top: 4px;">' +
                            '<span style="font-size: 10px; text-transform: uppercase; color: #667eea; font-weight: 600; margin-right: 8px;">üìû</span>' +
                            contactSection +
                        '</div>' : '');
                
                shiftsContainer.appendChild(shiftElement);
            });
        }
    </script>
</body>
</html>